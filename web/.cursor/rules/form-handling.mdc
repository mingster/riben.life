---
description: 
globs: 
alwaysApply: true
---
# Form Handling

- Use React Hook Form with Zod for validation
- The same validation should be done in the server action too

## Form Example

```tsx
import { zodResolver } from "@hookform/resolvers/zod";
import { Input } from "@/components/Input";
import { Button } from "@/components/ui/button";
import { toastSuccess, toastError } from "@/components/Toast";
import { createExampleAction } from "@/utils/actions/example";
import { type CreateExampleBody } from "@/utils/actions/example.validation";

export const ExampleForm = ({ emailAccountId }: { emailAccountId: string }) => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<CreateExampleBody>({
    resolver: zodResolver(schema),
  });

  const onSubmit: SubmitHandler<CreateExampleBody> = useCallback(
    async (data) => {
      const result = await createExampleAction(emailAccountId, data);
      
      if (result?.serverError) {
        toastError({ title: "Error", description: result.serverError });
      } else {
        toastSuccess({ description: "Created example!" });
      }
    },
    []
  );

  return (
    <form className="max-w-sm space-y-4" onSubmit={handleSubmit(onSubmit)}>
      <Input
        type="email"
        name="email"
        label="Email"
        registerProps={register("email", { required: true })}
        error={errors.email}
      />
      <Button type="submit" loading={isSubmitting}>
        Save
      </Button>
    </form>
  );
};
```

## Validation Guidelines

- **Always import validation schemas from action folders** - Never define local schemas in components
- Use the same validation schema for both client form validation and server action validation
- Import schemas from `@/actions/[domain]/[feature]/[action-name].validation.ts`
- If the schema includes fields not needed in the form (e.g., `storeId`), use `.omit()` to exclude them
- Use descriptive error messages
- Validate form inputs before submission
- Show validation errors inline next to form fields

## Schema Import Pattern

```tsx
// ✅ CORRECT: Import schema from action folder
import {
  updateRsvpSettingsSchema,
  type UpdateRsvpSettingsInput,
} from "@/actions/storeAdmin/rsvpSettings/update-rsvp-settings.validation";

// Form type: Omit fields that are added in submit handler (e.g., storeId)
type FormValues = Omit<UpdateRsvpSettingsInput, "storeId">;

const form = useForm<FormValues>({
  resolver: zodResolver(updateRsvpSettingsSchema.omit({ storeId: true })),
  defaultValues,
});
```

```tsx
// ❌ WRONG: Don't define local schema in component
const formSchema = z.object({
  // ... fields
});
```

## Conditional Schema Usage (Create vs Update)

When a form handles both create and update operations:

```tsx
import {
  createFacilitySchema,
  type CreateFacilityInput,
} from "@/actions/storeAdmin/facility/create-facility.validation";
import {
  updateFacilitySchema,
  type UpdateFacilityInput,
} from "@/actions/storeAdmin/facility/update-facility.validation";

const isEditMode = Boolean(facility) && !isNew;

// Use createFacilitySchema when isNew, updateFacilitySchema when editing
const schema = useMemo(
  () => (isEditMode ? updateFacilitySchema : createFacilitySchema),
  [isEditMode],
);

// Form input type: UpdateFacilityInput when editing, CreateFacilityInput when creating
type FormInput = Omit<UpdateFacilityInput, "id"> & { id?: string };

const form = useForm<FormInput>({
  resolver: zodResolver(schema) as Resolver<FormInput>,
  defaultValues,
});
```

## Required Field Indicators

**Always add an asterisk (*) to FormLabels for required fields** to clearly indicate which fields are mandatory.

### Pattern

```tsx
<FormField
  control={form.control}
  name="facilityName"
  render={({ field }) => (
    <FormItem>
      <FormLabel>
        {t("Facility_Name")} <span className="text-destructive">*</span>
      </FormLabel>
      <FormControl>
        <Input {...field} />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Determining Required Fields

A field is required if:
- It's defined in the Zod schema **without** `.optional()` or `.nullable()`
- It has `.min(1)` validation (for strings)
- It has `.min(0)` or `.min(1)` validation (for numbers) without `.optional()`

### Example

```tsx
// Schema
const schema = z.object({
  facilityName: z.string().min(1), // ✅ Required
  capacity: z.coerce.number().int().min(1), // ✅ Required
  description: z.string().optional().nullable(), // ❌ Optional
});

// Form
<FormLabel>
  {t("Facility_Name")} <span className="text-destructive">*</span>
</FormLabel>
<FormLabel>
  {t("Facility_Seats")} <span className="text-destructive">*</span>
</FormLabel>
<FormLabel>{t("facility_description")}</FormLabel> {/* No asterisk */}
```

### Styling

- Use `text-destructive` class for the asterisk to match error styling
- Place the asterisk immediately after the label text with a space
