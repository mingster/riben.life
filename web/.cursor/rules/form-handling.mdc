---
description: 
globs: 
alwaysApply: true
---
# Form Handling

- Use React Hook Form with Zod for validation
- The same validation should be done in the server action too

## Form Example

```tsx
import { zodResolver } from "@hookform/resolvers/zod";
import { Input } from "@/components/Input";
import { Button } from "@/components/ui/button";
import { toastSuccess, toastError } from "@/components/Toast";
import { createExampleAction } from "@/utils/actions/example";
import { type CreateExampleBody } from "@/utils/actions/example.validation";

export const ExampleForm = ({ emailAccountId }: { emailAccountId: string }) => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<CreateExampleBody>({
    resolver: zodResolver(schema),
  });

  const onSubmit: SubmitHandler<CreateExampleBody> = useCallback(
    async (data) => {
      const result = await createExampleAction(emailAccountId, data);
      
      if (result?.serverError) {
        toastError({ title: "Error", description: result.serverError });
      } else {
        toastSuccess({ description: "Created example!" });
      }
    },
    []
  );

  return (
    <form className="max-w-sm space-y-4" onSubmit={handleSubmit(onSubmit)}>
      <Input
        type="email"
        name="email"
        label="Email"
        registerProps={register("email", { required: true })}
        error={errors.email}
      />
      <Button type="submit" loading={isSubmitting}>
        Save
      </Button>
    </form>
  );
};
```

## Validation Guidelines

- **Always import validation schemas from action folders** - Never define local schemas in components
- Use the same validation schema for both client form validation and server action validation
- Import schemas from `@/actions/[domain]/[feature]/[action-name].validation.ts`
- If the schema includes fields not needed in the form (e.g., `storeId`), use `.omit()` to exclude them
- Use descriptive error messages
- Validate form inputs before submission
- Show validation errors inline next to form fields

## Schema Import Pattern

```tsx
// ✅ CORRECT: Import schema from action folder
import {
  updateRsvpSettingsSchema,
  type UpdateRsvpSettingsInput,
} from "@/actions/storeAdmin/rsvpSettings/update-rsvp-settings.validation";

// Form type: Omit fields that are added in submit handler (e.g., storeId)
type FormValues = Omit<UpdateRsvpSettingsInput, "storeId">;

const form = useForm<FormValues>({
  resolver: zodResolver(updateRsvpSettingsSchema.omit({ storeId: true })),
  defaultValues,
});
```

```tsx
// ❌ WRONG: Don't define local schema in component
const formSchema = z.object({
  // ... fields
});
```

## Conditional Schema Usage (Create vs Update)

When a form handles both create and update operations:

```tsx
import {
  createFacilitySchema,
  type CreateFacilityInput,
} from "@/actions/storeAdmin/facility/create-facility.validation";
import {
  updateFacilitySchema,
  type UpdateFacilityInput,
} from "@/actions/storeAdmin/facility/update-facility.validation";

const isEditMode = Boolean(facility) && !isNew;

// Use createFacilitySchema when isNew, updateFacilitySchema when editing
const schema = useMemo(
  () => (isEditMode ? updateFacilitySchema : createFacilitySchema),
  [isEditMode],
);

// Form input type: UpdateFacilityInput when editing, CreateFacilityInput when creating
type FormInput = Omit<UpdateFacilityInput, "id"> & { id?: string };

const form = useForm<FormInput>({
  resolver: zodResolver(schema) as Resolver<FormInput>,
  defaultValues,
});
```

## Required Field Indicators

**Always add an asterisk (*) to FormLabels for required fields** to clearly indicate which fields are mandatory.

### Pattern

```tsx
<FormField
  control={form.control}
  name="facilityName"
  render={({ field }) => (
    <FormItem>
      <FormLabel>
        {t("Facility_Name")} <span className="text-destructive">*</span>
      </FormLabel>
      <FormControl>
        <Input {...field} />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Determining Required Fields

A field is required if:
- It's defined in the Zod schema **without** `.optional()` or `.nullable()`
- It has `.min(1)` validation (for strings)
- It has `.min(0)` or `.min(1)` validation (for numbers) without `.optional()`

### Example

```tsx
// Schema
const schema = z.object({
  facilityName: z.string().min(1), // ✅ Required
  capacity: z.coerce.number().int().min(1), // ✅ Required
  description: z.string().optional().nullable(), // ❌ Optional
});

// Form
<FormLabel>
  {t("Facility_Name")} <span className="text-destructive">*</span>
</FormLabel>
<FormLabel>
  {t("Facility_Seats")} <span className="text-destructive">*</span>
</FormLabel>
<FormLabel>{t("facility_description")}</FormLabel> {/* No asterisk */}
```

### Styling

- Use `text-destructive` class for the asterisk to match error styling
- Place the asterisk immediately after the label text with a space

## Select Component Values

**CRITICAL: Never use empty string (`""`) as a value for `SelectItem` components.**

Empty string values can cause issues with form validation, state management, and component behavior. Always use a placeholder value like `"--"` for optional/nullable selections.

### Pattern

```tsx
// ✅ CORRECT: Use placeholder value for optional/nullable fields
<Select
  value={field.value || "--"}
  onValueChange={(value) =>
    field.onChange(value === "--" ? null : value)
  }
>
  <SelectTrigger>
    <SelectValue placeholder="Select an option (optional)" />
  </SelectTrigger>
  <SelectContent>
    <SelectItem value="--">None</SelectItem>
    {options.map((option) => (
      <SelectItem key={option.id} value={option.id}>
        {option.name}
      </SelectItem>
    ))}
  </SelectContent>
</Select>
```

```tsx
// ❌ WRONG: Don't use empty string as value
<SelectItem value="">None</SelectItem>

// ❌ WRONG: Don't use empty string in value prop
<Select value={field.value || ""}>
```

### Rules

1. **Use `"--"` as placeholder value** for optional/nullable Select fields
2. **Convert `"--"` to `null`** in `onValueChange` handler
3. **Use `"--"` as fallback** in `value` prop when field value is null/undefined
4. **Never use empty string (`""`)** as a SelectItem value

### Example: Optional Store Selection

```tsx
<FormField
  control={form.control}
  name="storeId"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Store</FormLabel>
      <FormControl>
        <Select
          value={field.value || "--"}
          onValueChange={(value) =>
            field.onChange(value === "--" ? null : value)
          }
        >
          <SelectTrigger>
            <SelectValue placeholder="Select a store (optional)" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="--">None</SelectItem>
            {stores.map((store) => (
              <SelectItem key={store.id} value={store.id}>
                {store.name}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Example: Optional Template Selection

```tsx
<FormField
  control={form.control}
  name="templateId"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Template</FormLabel>
      <Select
        onValueChange={(value) =>
          field.onChange(value === "--" ? null : value)
        }
        value={field.value || "--"}
      >
        <FormControl>
          <SelectTrigger>
            <SelectValue placeholder="Select a template (optional)" />
          </SelectTrigger>
        </FormControl>
        <SelectContent>
          <SelectItem value="--">None</SelectItem>
          {templates.map((template) => (
            <SelectItem key={template.id} value={template.id}>
              {template.name}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      <FormDescription className="text-xs font-mono text-gray-500">
        Optional: Use a message template for consistent formatting
      </FormDescription>
      <FormMessage />
    </FormItem>
  )}
/>
```

## FormDescription Styling Standard

**CRITICAL: All `FormDescription` components must use the standard className for consistency across the entire project.**

### Standard Pattern

All `FormDescription` components must use this exact className:

```tsx
<FormDescription className="text-xs font-mono text-gray-500">
  {descriptionText}
</FormDescription>
```

### Rules

1. **Always use `className="text-xs font-mono text-gray-500"`** for all FormDescription components
2. **Never use different className values** like `text-muted-foreground` or omit className entirely
3. **Apply to all instances** including empty FormDescription components: `<FormDescription className="text-xs font-mono text-gray-500" />`

### Examples

```tsx
// ✅ CORRECT: Standard styling
<FormDescription className="text-xs font-mono text-gray-500">
  {t("field_description")}
</FormDescription>

// ✅ CORRECT: Empty FormDescription with standard styling
<FormDescription className="text-xs font-mono text-gray-500" />

// ❌ WRONG: Missing className
<FormDescription>
  {t("field_description")}
</FormDescription>

// ❌ WRONG: Different className
<FormDescription className="text-xs text-muted-foreground font-mono">
  {t("field_description")}
</FormDescription>
```

### Complete Form Field Example

```tsx
<FormField
  control={form.control}
  name="description"
  render={({ field }) => (
    <FormItem>
      <FormLabel>
        {t("Description")} <span className="text-destructive">*</span>
      </FormLabel>
      <FormControl>
        <Textarea {...field} />
      </FormControl>
      <FormDescription className="text-xs font-mono text-gray-500">
        {t("description_helper_text")}
      </FormDescription>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Why This Standard?

- **Consistency**: Ensures all form descriptions have the same visual appearance
- **Readability**: Small, monospace font with gray color provides subtle but clear helper text
- **Maintainability**: Single standard makes it easy to update styling globally if needed
