---
description: Form handling with React Hook Form, Zod, validation, and standard loader + UI lock on submission
globs: 
alwaysApply: true
---
# Form Handling

- Use React Hook Form with Zod for validation
- The same validation should be done in the server action too
- **Standard:** Show loader and lock UI during all form submissions (see Form Submission Loader and UI Lock)

## Form Example

```tsx
import { zodResolver } from "@hookform/resolvers/zod";
import { Input } from "@/components/Input";
import { Button } from "@/components/ui/button";
import { toastSuccess, toastError } from "@/components/Toast";
import { createExampleAction } from "@/utils/actions/example";
import { type CreateExampleBody } from "@/utils/actions/example.validation";

export const ExampleForm = ({ emailAccountId }: { emailAccountId: string }) => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<CreateExampleBody>({
    resolver: zodResolver(schema),
  });

  const onSubmit: SubmitHandler<CreateExampleBody> = useCallback(
    async (data) => {
      const result = await createExampleAction(emailAccountId, data);
      
      if (result?.serverError) {
        toastError({ title: "Error", description: result.serverError });
      } else {
        toastSuccess({ description: "Created example!" });
      }
    },
    []
  );

  return (
    <form className="max-w-sm space-y-4" onSubmit={handleSubmit(onSubmit)}>
      <Input
        type="email"
        name="email"
        label="Email"
        registerProps={register("email", { required: true })}
        error={errors.email}
      />
      <Button type="submit" loading={isSubmitting}>
        Save
      </Button>
    </form>
  );
};
```

## Form Submission Loader and UI Lock (Standard)

**All form submissions must show a loader and lock the UI until the submission completes.** This prevents double-submit, gives clear feedback, and blocks interaction during async work.

### Requirements

1. **Loading state**: Set loading/submitting state at the very start of the submit handler (after validation passes). Clear it in all exit paths and in a `finally` block.
2. **Overlay**: When submitting, show a full-area overlay above the form with:
   - Centered spinner (e.g. `ClipLoader` from `react-spinners`, size 40)
   - Short status text (e.g. `t("submitting")`, `t("updating")`, `t("cancelling")`)
   - Semi-opaque background and optional backdrop blur (e.g. `bg-background/80 backdrop-blur-[2px]`)
   - High z-index (e.g. `z-[100]`) so it sits above dialogs
3. **Lock UI**: Overlay must block all interaction:
   - `cursor-wait` on the overlay
   - `select-none` so text cannot be selected through the overlay
   - Disable all primary actions (submit button, close/cancel, secondary submit buttons) via `disabled={isSubmitting}` or equivalent
4. **Accessibility**: Root container: `aria-busy={isSubmitting}`. Overlay: `aria-live="polite"` and `aria-label` with the status text.

### Pattern

```tsx
const [isSubmitting, setIsSubmitting] = useState(false);

async function handleSubmit() {
  // ... validation, early returns (do not set isSubmitting yet)
  setIsSubmitting(true);
  try {
    const result = await someAction(data);
    if (result?.serverError) {
      toastError({ description: result.serverError });
      return;
    }
    toastSuccess({ description: "Saved." });
    onSuccess?.(result.data);
  } catch (error) {
    toastError({ description: error instanceof Error ? error.message : String(error) });
  } finally {
    setIsSubmitting(false);
  }
}

return (
  <div className="relative" aria-busy={isSubmitting} aria-disabled={isSubmitting}>
    {isSubmitting && (
      <div
        className="absolute inset-0 z-[100] flex cursor-wait select-none items-center justify-center rounded-lg bg-background/80 backdrop-blur-[2px]"
        aria-live="polite"
        aria-label={t("submitting")}
      >
        <div className="flex flex-col items-center gap-3">
          <ClipLoader size={40} color="#3498db" />
          <span className="text-sm font-medium text-muted-foreground">{t("submitting")}</span>
        </div>
      </div>
    )}
    {/* form content; buttons use disabled={isSubmitting} */}
  </div>
);
```

### Where to Apply

- Any form or view that submits data (create reservation, update settings, cancel, delete, etc.).
- Use the same pattern in both React Hook Form flows and non–react-hook-form submit handlers (e.g. facility reservation client).

### References

- `web/src/app/s/[storeId]/reservation/[facilityId]/components/facility-reservation-client.tsx` (create reservation overlay + lock)
- `web/src/app/s/[storeId]/reservation/history/components/customer-reservation-history-client.tsx` (cancel/edit overlay)
- `web/src/app/s/[storeId]/reservation/components/reservation-form.tsx` (form overlay when `isSubmitting`)

## Validation Guidelines

- **Always import validation schemas from action folders** - Never define local schemas in components
- Use the same validation schema for both client form validation and server action validation
- Import schemas from `@/actions/[domain]/[feature]/[action-name].validation.ts`
- If the schema includes fields not needed in the form (e.g., `storeId`), use `.omit()` to exclude them
- Use descriptive error messages
- Validate form inputs before submission
- Show validation errors inline next to form fields

## Schema Import Pattern

```tsx
// ✅ CORRECT: Import schema from action folder
import {
  updateRsvpSettingsSchema,
  type UpdateRsvpSettingsInput,
} from "@/actions/storeAdmin/rsvpSettings/update-rsvp-settings.validation";

// Form type: Omit fields that are added in submit handler (e.g., storeId)
type FormValues = Omit<UpdateRsvpSettingsInput, "storeId">;

const form = useForm<FormValues>({
  resolver: zodResolver(updateRsvpSettingsSchema.omit({ storeId: true })),
  defaultValues,
});
```

```tsx
// ❌ WRONG: Don't define local schema in component
const formSchema = z.object({
  // ... fields
});
```

## Conditional Schema Usage (Create vs Update)

When a form handles both create and update operations:

```tsx
import {
  createFacilitySchema,
  type CreateFacilityInput,
} from "@/actions/storeAdmin/facility/create-facility.validation";
import {
  updateFacilitySchema,
  type UpdateFacilityInput,
} from "@/actions/storeAdmin/facility/update-facility.validation";

const isEditMode = Boolean(facility) && !isNew;

// Use createFacilitySchema when isNew, updateFacilitySchema when editing
const schema = useMemo(
  () => (isEditMode ? updateFacilitySchema : createFacilitySchema),
  [isEditMode],
);

// Form input type: UpdateFacilityInput when editing, CreateFacilityInput when creating
type FormInput = Omit<UpdateFacilityInput, "id"> & { id?: string };

const form = useForm<FormInput>({
  resolver: zodResolver(schema) as Resolver<FormInput>,
  defaultValues,
});
```

## Required Field Indicators

**Always add an asterisk (*) to FormLabels for required fields** to clearly indicate which fields are mandatory.

### Pattern

```tsx
<FormField
  control={form.control}
  name="facilityName"
  render={({ field }) => (
    <FormItem>
      <FormLabel>
        {t("Facility_Name")} <span className="text-destructive">*</span>
      </FormLabel>
      <FormControl>
        <Input {...field} />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Determining Required Fields

A field is required if:
- It's defined in the Zod schema **without** `.optional()` or `.nullable()`
- It has `.min(1)` validation (for strings)
- It has `.min(0)` or `.min(1)` validation (for numbers) without `.optional()`

### Example

```tsx
// Schema
const schema = z.object({
  facilityName: z.string().min(1), // ✅ Required
  capacity: z.coerce.number().int().min(1), // ✅ Required
  description: z.string().optional().nullable(), // ❌ Optional
});

// Form
<FormLabel>
  {t("Facility_Name")} <span className="text-destructive">*</span>
</FormLabel>
<FormLabel>
  {t("Facility_Seats")} <span className="text-destructive">*</span>
</FormLabel>
<FormLabel>{t("facility_description")}</FormLabel> {/* No asterisk */}
```

### Styling

- Use `text-destructive` class for the asterisk to match error styling
- Place the asterisk immediately after the label text with a space

## Select Component Values

**CRITICAL: Never use empty string (`""`) as a value for `SelectItem` components.**

Empty string values can cause issues with form validation, state management, and component behavior. Always use a placeholder value like `"--"` for optional/nullable selections.

### Pattern

```tsx
// ✅ CORRECT: Use placeholder value for optional/nullable fields
<Select
  value={field.value || "--"}
  onValueChange={(value) =>
    field.onChange(value === "--" ? null : value)
  }
>
  <SelectTrigger>
    <SelectValue placeholder="Select an option (optional)" />
  </SelectTrigger>
  <SelectContent>
    <SelectItem value="--">None</SelectItem>
    {options.map((option) => (
      <SelectItem key={option.id} value={option.id}>
        {option.name}
      </SelectItem>
    ))}
  </SelectContent>
</Select>
```

```tsx
// ❌ WRONG: Don't use empty string as value
<SelectItem value="">None</SelectItem>

// ❌ WRONG: Don't use empty string in value prop
<Select value={field.value || ""}>
```

### Rules

1. **Use `"--"` as placeholder value** for optional/nullable Select fields
2. **Convert `"--"` to `null`** in `onValueChange` handler
3. **Use `"--"` as fallback** in `value` prop when field value is null/undefined
4. **Never use empty string (`""`)** as a SelectItem value

### Example: Optional Store Selection

```tsx
<FormField
  control={form.control}
  name="storeId"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Store</FormLabel>
      <FormControl>
        <Select
          value={field.value || "--"}
          onValueChange={(value) =>
            field.onChange(value === "--" ? null : value)
          }
        >
          <SelectTrigger>
            <SelectValue placeholder="Select a store (optional)" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="--">None</SelectItem>
            {stores.map((store) => (
              <SelectItem key={store.id} value={store.id}>
                {store.name}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Example: Optional Template Selection

```tsx
<FormField
  control={form.control}
  name="templateId"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Template</FormLabel>
      <Select
        onValueChange={(value) =>
          field.onChange(value === "--" ? null : value)
        }
        value={field.value || "--"}
      >
        <FormControl>
          <SelectTrigger>
            <SelectValue placeholder="Select a template (optional)" />
          </SelectTrigger>
        </FormControl>
        <SelectContent>
          <SelectItem value="--">None</SelectItem>
          {templates.map((template) => (
            <SelectItem key={template.id} value={template.id}>
              {template.name}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      <FormDescription className="text-xs font-mono text-gray-500">
        Optional: Use a message template for consistent formatting
      </FormDescription>
      <FormMessage />
    </FormItem>
  )}
/>
```

## FormDescription Styling Standard

**CRITICAL: All `FormDescription` components must use the standard className for consistency across the entire project.**

### Standard Pattern

All `FormDescription` components must use this exact className:

```tsx
<FormDescription className="text-xs font-mono text-gray-500">
  {descriptionText}
</FormDescription>
```

### Rules

1. **Always use `className="text-xs font-mono text-gray-500"`** for all FormDescription components
2. **Never use different className values** like `text-muted-foreground` or omit className entirely
3. **Apply to all instances** including empty FormDescription components: `<FormDescription className="text-xs font-mono text-gray-500" />`

### Examples

```tsx
// ✅ CORRECT: Standard styling
<FormDescription className="text-xs font-mono text-gray-500">
  {t("field_description")}
</FormDescription>

// ✅ CORRECT: Empty FormDescription with standard styling
<FormDescription className="text-xs font-mono text-gray-500" />

// ❌ WRONG: Missing className
<FormDescription>
  {t("field_description")}
</FormDescription>

// ❌ WRONG: Different className
<FormDescription className="text-xs text-muted-foreground font-mono">
  {t("field_description")}
</FormDescription>
```

### Complete Form Field Example

```tsx
<FormField
  control={form.control}
  name="description"
  render={({ field }) => (
    <FormItem>
      <FormLabel>
        {t("Description")} <span className="text-destructive">*</span>
      </FormLabel>
      <FormControl>
        <Textarea {...field} />
      </FormControl>
      <FormDescription className="text-xs font-mono text-gray-500">
        {t("description_helper_text")}
      </FormDescription>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Why This Standard?

- **Consistency**: Ensures all form descriptions have the same visual appearance
- **Readability**: Small, monospace font with gray color provides subtle but clear helper text
- **Maintainability**: Single standard makes it easy to update styling globally if needed

## Form Validation and Error Display

**Standard Pattern (Based on EditUser):**

### Validation Mode

Always use `mode: "onChange"` for real-time validation feedback:

```tsx
const form = useForm<FormInput>({
  resolver: zodResolver(schema),
  defaultValues,
  mode: "onChange", // ✅ Real-time validation
});
```

### Error Summary Display

Display all validation errors in a summary box above the submit button:

```tsx
{Object.keys(form.formState.errors).length > 0 && (
  <div className="rounded-md bg-destructive/15 border border-destructive/50 p-3 space-y-1.5">
    <div className="text-sm font-semibold text-destructive">
      Please fix the following errors:
    </div>
    {Object.entries(form.formState.errors).map(([field, error]) => {
      // Map field names to user-friendly labels using i18n
      const fieldLabels: Record<string, string> = {
        name: t("name"),
        email: t("email"),
        phoneNumber: t("phone"),
        // ... map all fields
      };
      const fieldLabel = fieldLabels[field] || field;
      return (
        <div
          key={field}
          className="text-sm text-destructive flex items-start gap-2"
        >
          <span className="font-medium">{fieldLabel}:</span>
          <span>{error.message as string}</span>
        </div>
      );
    })}
  </div>
)}
```

### Submit Button State

Disable the submit button when the form is invalid:

```tsx
<Button
  type="submit"
  disabled={
    loading ||
    !form.formState.isValid || // ✅ Disable when invalid
    form.formState.isSubmitting
  }
  className="disabled:opacity-25"
>
  {t("submit")}
</Button>
```

### Conditional Validation with .refine()

Use `.refine()` in the Zod schema for conditional validation:

```tsx
export const updateUserSettingsSchema = z
  .object({
    banned: z.boolean().optional(),
    banReason: z.string().nullable().optional(),
    phoneNumber: z.string().optional(),
    phoneNumberVerified: z.boolean().optional(),
    // ... other fields
  })
  .refine(
    (data) => {
      // If banned is true, banReason must be provided
      if (data.banned === true) {
        return (
          data.banReason !== null &&
          data.banReason !== undefined &&
          data.banReason.trim() !== ""
        );
      }
      return true;
    },
    {
      message: "Ban reason is required when user is banned",
      path: ["banReason"],
    },
  )
  .refine(
    (data) => {
      // If phoneNumberVerified is true, phoneNumber must have a value
      if (data.phoneNumberVerified === true) {
        return (
          data.phoneNumber !== null &&
          data.phoneNumber !== undefined &&
          data.phoneNumber.trim() !== ""
        );
      }
      return true;
    },
    {
      message: "Phone number is required when phone number is verified",
      path: ["phoneNumber"],
    },
  );
```

**Key Points:**

- ✅ Use `mode: "onChange"` for real-time validation
- ✅ Display all errors in a summary box above submit button
- ✅ Map field names to user-friendly labels using i18n
- ✅ Disable submit button when `!form.formState.isValid`
- ✅ Use `.refine()` for conditional validation rules
- ✅ Each `.refine()` should have a clear `path` to the field that fails

## Form Field Error Highlighting

**CRITICAL: All form fields with validation errors must be visually highlighted to clearly indicate which fields need attention.**

### Visual Error Indicators

When a form field has a validation error, it should display:

1. **Red border** around the input/textarea/select component
2. **Light red background** on the FormItem container
3. **Red error message** below the field (via FormMessage)
4. **Red focus ring** when the field is focused

### Standard Pattern

All FormField components must use this pattern for error highlighting:

```tsx
import { cn } from "@/lib/utils";

<FormField
  control={form.control}
  name="fieldName"
  render={({ field, fieldState }) => (
    <FormItem
      className={cn(
        fieldState.error &&
          "rounded-md border border-destructive/50 bg-destructive/5 p-2",
      )}
    >
      <FormLabel>
        {t("Field_Label")} <span className="text-destructive">*</span>
      </FormLabel>
      <FormControl>
        <Input
          {...field}
          className={cn(
            "h-10 text-base sm:h-9 sm:text-sm",
            fieldState.error &&
              "border-destructive focus-visible:ring-destructive",
          )}
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Error Highlighting Components

#### Input Fields

```tsx
<FormField
  control={form.control}
  name="name"
  render={({ field, fieldState }) => (
    <FormItem
      className={cn(
        fieldState.error &&
          "rounded-md border border-destructive/50 bg-destructive/5 p-2",
      )}
    >
      <FormLabel>
        {t("name")} <span className="text-destructive">*</span>
      </FormLabel>
      <FormControl>
        <Input
          {...field}
          className={cn(
            "h-10 text-base sm:h-9 sm:text-sm",
            fieldState.error &&
              "border-destructive focus-visible:ring-destructive",
          )}
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

#### Textarea Fields

```tsx
<FormField
  control={form.control}
  name="description"
  render={({ field, fieldState }) => (
    <FormItem
      className={cn(
        fieldState.error &&
          "rounded-md border border-destructive/50 bg-destructive/5 p-2",
      )}
    >
      <FormLabel>
        {t("Description")} <span className="text-destructive">*</span>
      </FormLabel>
      <FormControl>
        <Textarea
          {...field}
          className={cn(
            "font-mono min-h-[100px]",
            fieldState.error &&
              "border-destructive focus-visible:ring-destructive",
          )}
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

#### Select/Combobox Fields

```tsx
<FormField
  control={form.control}
  name="userId"
  render={({ field, fieldState }) => (
    <FormItem
      className={cn(
        fieldState.error &&
          "rounded-md border border-destructive/50 bg-destructive/5 p-2",
      )}
    >
      <FormLabel>
        {t("user")} <span className="text-destructive">*</span>
      </FormLabel>
      <FormControl>
        <UserCombobox
          value={field.value}
          onValueChange={field.onChange}
          className={
            fieldState.error
              ? "border-destructive focus-visible:ring-destructive"
              : ""
          }
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

**Note:** Custom combobox components must accept a `className` prop to apply error styling.

### Error Styling Classes

#### FormItem Container

```tsx
className={cn(
  fieldState.error &&
    "rounded-md border border-destructive/50 bg-destructive/5 p-2",
)}
```

- `rounded-md`: Rounded corners for the container
- `border border-destructive/50`: Red border at 50% opacity
- `bg-destructive/5`: Light red background at 5% opacity
- `p-2`: Padding to create visual space around the field

#### Input/Textarea/Select Components

```tsx
className={cn(
  "base-classes",
  fieldState.error &&
    "border-destructive focus-visible:ring-destructive",
)}
```

- `border-destructive`: Red border on the input
- `focus-visible:ring-destructive`: Red focus ring when focused

### Dynamic Validation Triggering

For fields that need conditional validation (e.g., required only in certain modes), trigger validation when values change:

```tsx
<Input
  {...field}
  onChange={(e) => {
    const value = e.target.value;
    field.onChange(value);
    // Trigger validation for related fields
    if (someCondition) {
      form.trigger(["fieldName", "relatedField"]);
    }
  }}
/>
```

### Complete Example

```tsx
import { cn } from "@/lib/utils";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";

const form = useForm<FormInput>({
  resolver: zodResolver(schema),
  defaultValues,
  mode: "onChange", // Real-time validation
});

<Form {...form}>
  <form onSubmit={form.handleSubmit(onSubmit)}>
    <FormField
      control={form.control}
      name="name"
      render={({ field, fieldState }) => (
        <FormItem
          className={cn(
            fieldState.error &&
              "rounded-md border border-destructive/50 bg-destructive/5 p-2",
          )}
        >
          <FormLabel>
            {t("name")} <span className="text-destructive">*</span>
          </FormLabel>
          <FormControl>
            <Input
              {...field}
              className={cn(
                "h-10 text-base sm:h-9 sm:text-sm",
                fieldState.error &&
                  "border-destructive focus-visible:ring-destructive",
              )}
            />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
  </form>
</Form>
```

### Rules

1. **Always destructure `fieldState`** in FormField render function to access error state
2. **Always apply error styling** to both FormItem container and input component
3. **Always use `cn()` utility** for conditional class names
4. **Always include FormMessage** to display error text below the field
5. **Use consistent error styling** across all form fields in the application

### Benefits

- **Clear visual feedback**: Users immediately see which fields have errors
- **Improved UX**: Red highlighting draws attention to problems
- **Accessibility**: Visual indicators complement error messages
- **Consistency**: Uniform error styling across the application
