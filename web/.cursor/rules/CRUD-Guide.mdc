---
name: CRUD Guide (Modern Client State Pattern)
description: Guide to managing data (CRUD operations - Create, Read, Update, Delete)
globs: ["**/*.{js,ts,jsx,tsx,mdx,css}"]
alwaysApply: true
---

# Standard CRUD Operation Pattern  (Modern Client State Pattern)

This application follows a modern pattern for managing data (CRUD operations - Create, Read, Update, Delete) in this Next.js App Router projects.

## Key Principles

- **Local State Management:** The main client component (e.g., `client-table.tsx`) holds the data array in local state (`useState`).
- **Edit/Create Dialogs:** Edit and create forms (e.g., `edit-table-dialog.tsx`) are rendered as modals or drawers and receive callbacks from the parent.
- **Direct State Updates:** After a mutation (create, update, delete), the parent updates its local state array directly, ensuring the UI is always in sync.
- **No router.refresh for Client State:** Do **not** rely on `router.refresh()` to update client-side state. Only use it if you want to re-fetch server components.
- **Type Safety:** Always ensure new/updated items include all required fields for the state array's type.

## Structure

- Each CRUD resource has its own directory under `/*/RESOURCE_NAME`.
- The main page (e.g., @`page.tsx`) fetches data on the server and passes it to a client component.
- The client component (e.g., @`client-sysmsg.tsx`) handles displaying the data in a table, as well as client-side state for create, update, and delete operations.
- Editing and creating items is handled by a dedicated form/dialog component (e.g., @`edit-sysmsg.tsx`), which uses a modal dialog and react-hook-form for validation and submission.
- Actions (edit, delete, copy, etc.) are provided via dropdown menus and confirmation dialogs in `CellAction` function.
- Data is updated optimistically on the client after successful server actions.

## Key Conventions

1. **Server Data Fetching:**  
   Fetch all data for the resource in the main page server component and pass it as props to the client component.

2. **Client Table Component:**  
   - Receives the server data as a prop.
   - Manages local state for the data array.
   - `CellAction` function provides dropdown menus and confirmation dialogs for delete mutation.

3. **Edit/Create Dialog:**  
   - Uses a modal dialog for editing or creating items.
   - Uses react-hook-form and zod for validation.
   - **Always imports validation schemas from action folders** - Never defines local schemas in components.
   - If handling both create and update, conditionally selects the appropriate schema based on `isNew` prop.
   - Calls server actions for create/edit mutations.
   - Notifies the parent component to update local state after mutation.

4. **Actions:**  
   - Use dropdown menus for row actions (edit, delete, copy, etc.).
   - Use confirmation dialogs for destructive actions.

5. **UI Components:**  
   - Use shadcn/ui components for table, dialog, button, etc.
   - Use Suspense and Loader for async loading states.

## Example Reference

**Canonical CRUD Example (Standard Pattern):**

- Edit/Create dialog: @`/sysAdmin/users/components/edit-user.tsx` ⭐ **Use this as the standard reference**
- Validation schema: @`/actions/sysAdmin/user/user.validation.ts`
- Server action: @`/actions/sysAdmin/user/update-user.ts`

**Other Examples:**

- Main CRUD page: @`/storeAdmin/[storeId]/tables/page.tsx`
- Client table: @`/storeAdmin/[storeId]/(routes)/tables/components/client-table.tsx`
- Edit/Create dialog: @`/storeAdmin/[storeId]/(routes)/tables/components/edit-table-dialog.tsx`
- Bulk create dialog: @`/storeAdmin/[storeId]/(routes)/tables/components/bulk-add-tables-dialog.tsx`

---

**Follow this pattern for all new CRUD resources in the admin section for consistency and maintainability.**

## Example Pattern

### 1. Define/Create type in `@/src/types.d.ts`

### 2. Create server action and zod validation using as defined in [server-action.mdc](mdc:.cursor/rules/server-action.mdc)

### 3. Create a Server page (page.tsx) to host an unique URL entry

```tsx
import { transformPrismaDataForJson } from "@/utils/utils";

export default async function [object_name]AdminPage(props: {
 params: Params;
 searchParams: SearchParams;
}) {
 //const _params = await props.params;
 const obj = (await sqlClient.[object_name].findMany(
  {},
 )) as object_name[];
 
 // Transform BigInt (epoch timestamps) and Decimal to numbers for JSON serialization
 transformPrismaDataForJson(obj);

 return (
  <Suspense fallback={<Loader />}>
   <Container>
    <[object_name]Client serverData={obj} />
   </Container>
  </Suspense>
 );
}

```

### 4. Client List Component (holds state)

```tsx
const [data, setData] = useState<ItemType[]>(serverData);

const handleCreated = (newItem: ItemType) => {
  setData(prev => [...prev, newItem]);
};
const handleUpdated = (updatedItem: ItemType) => {
  setData(prev => prev.map(item => item.id === updatedItem.id ? { ...item, ...updatedItem } : item));
};
const handleDeleted = (deletedItem: ItemType) => {
  setData(prev => prev.filter(item => item.id !== deletedItem.id));
};
```

### 5. Pass Callbacks to Edit/Create Components

```tsx
<EditItem item={row.original} onUpdated={handleUpdated} />
<EditItem item={newObj} onCreated={handleCreated} isNew={true} />
<ActionCell item={row.original} onDeleted={handleDeleted} />
```

### 6. Edit/Create Component (Standard Pattern - Use EditUser as Reference)

**Standard Pattern (Based on EditUser):**

```tsx
// Import validation schema and type from action folder
import {
  type UpdateUserSettingsInput,
  updateUserSettingsSchema,
} from "@/actions/sysAdmin/user/user.validation";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";

// Prepare default values from item prop
const defaultValues = item
  ? {
      ...item,
      // Convert date fields to ISO strings for datetime-local inputs
      banExpires: item.banExpires
        ? new Date(item.banExpires).toISOString()
        : undefined,
    }
  : {};

// Use form with direct type import (no need for FormInput type)
const form = useForm<UpdateUserSettingsInput>({
  resolver: zodResolver(updateUserSettingsSchema),
  defaultValues,
  mode: "onChange", // Real-time validation
});

async function onSubmit(data: UpdateUserSettingsInput) {
  setLoading(true);
  
  let result: { data?: ItemType; serverError?: string } | null;
  if (isNew) {
    // Handle create logic (e.g., create user via auth client first)
    result = await createItemAction(data);
  } else {
    result = await updateItemAction(data);
  }
  
  if (!result) {
    toastError({ description: "An error occurred" });
  } else if (result.serverError) {
    toastError({ description: result.serverError });
  } else {
    toastSuccess({ description: "Profile updated." });
    if (result.data) {
      onUpdated?.(result.data as ItemType);
    }
  }
  setLoading(false);
  setIsOpen(false);
}
```

**Key Points:**

- ✅ **Always import schema and type directly** from `@/actions/[domain]/[feature]/[action-name].validation.ts`
- ✅ **Use the schema type directly** (e.g., `UpdateUserSettingsInput`) - no need for a separate `FormInput` type
- ✅ **Use `mode: "onChange"`** for real-time validation feedback
- ✅ **Never define local schemas** in component files
- ✅ **Use `.refine()` in the schema** for conditional validation (e.g., required field when another field is true)

#### Form Field Patterns

**Standard Input Field:**

```tsx
<FormField
  control={form.control}
  name="name"
  render={({ field }) => (
    <FormItem>
      <FormLabel>
        {t("name")} <span className="text-destructive">*</span>
      </FormLabel>
      <FormControl>
        <Input
          disabled={loading || form.formState.isSubmitting}
          placeholder="Enter name"
          {...field}
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

**Optional Field (with null handling):**

```tsx
<FormField
  control={form.control}
  name="phoneNumber"
  render={({ field }) => (
    <FormItem>
      <FormLabel>{t("phone") || "Phone"}</FormLabel>
      <FormControl>
        <Input
          disabled={loading || form.formState.isSubmitting}
          placeholder="+886912345678 or +14155551212"
          type="tel"
          {...field}
          value={field.value ?? ""} // Handle null/undefined
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

**Checkbox Field:**

```tsx
<FormField
  control={form.control}
  name="banned"
  render={({ field }) => (
    <FormItem className="flex flex-row items-start space-x-3 space-y-0">
      <FormControl>
        <Checkbox
          checked={Boolean(field.value)}
          onCheckedChange={(checked) =>
            field.onChange(checked === true)
          }
          disabled={loading || form.formState.isSubmitting}
        />
      </FormControl>
      <div className="space-y-1 leading-none">
        <FormLabel>{t("banned") || "Banned"}</FormLabel>
      </div>
    </FormItem>
  )}
/>
```

**Conditional Field Rendering:**

```tsx
{form.watch("banned") && (
  <FormField
    control={form.control}
    name="banReason"
    render={({ field }) => (
      <FormItem>
        <FormLabel>{t("ban_reason") || "Ban Reason"}</FormLabel>
        <FormControl>
          <Textarea
            disabled={loading || form.formState.isSubmitting}
            placeholder="Enter ban reason"
            {...field}
            value={field.value ?? ""}
          />
        </FormControl>
        <FormMessage />
      </FormItem>
    )}
  />
)}
```

**Date/Time Field (datetime-local):**

```tsx
<FormField
  control={form.control}
  name="banExpires"
  render={({ field }) => (
    <FormItem>
      <FormLabel>{t("ban_expires") || "Ban Expires"}</FormLabel>
      <FormControl>
        <Input
          disabled={loading || form.formState.isSubmitting}
          type="datetime-local"
          {...field}
          value={
            field.value
              ? new Date(field.value).toISOString().slice(0, 16)
              : ""
          }
          onChange={(e) => {
            field.onChange(
              e.target.value ? new Date(e.target.value).toISOString() : ""
            );
          }}
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

**Validation Error Summary:**

```tsx
{Object.keys(form.formState.errors).length > 0 && (
  <div className="rounded-md bg-destructive/15 border border-destructive/50 p-3 space-y-1.5">
    <div className="text-sm font-semibold text-destructive">
      Please fix the following errors:
    </div>
    {Object.entries(form.formState.errors).map(([field, error]) => {
      // Map field names to user-friendly labels using i18n
      const fieldLabels: Record<string, string> = {
        name: t("name"),
        email: t("email"),
        // ... map all fields
      };
      const fieldLabel = fieldLabels[field] || field;
      return (
        <div
          key={field}
          className="text-sm text-destructive flex items-start gap-2"
        >
          <span className="font-medium">{fieldLabel}:</span>
          <span>{error.message as string}</span>
        </div>
      );
    })}
  </div>
)}
```

**Submit Button with Validation:**

```tsx
<Button
  type="submit"
  disabled={
    loading ||
    !form.formState.isValid || // Disable when form is invalid
    form.formState.isSubmitting
  }
  className="disabled:opacity-25"
>
  {t("submit")}
</Button>
```

### Date/Time Handling in CRUD Operations

**CRITICAL: All date/time values are stored as BigInt epoch time (milliseconds since 1970-01-01 UTC).**

When creating or updating records with date/time fields:

1. **In Server Actions:**
   - Always use `getUtcNowEpoch()` from `@/utils/datetime-utils` for timestamps (returns BigInt)
   - Convert Date objects to BigInt using `dateToEpoch()` before saving
   - Convert user input dates to UTC Date first, then to BigInt epoch
   - Never use `new Date()` or `Date.now()` directly for database timestamps

2. **In Client Components:**
   - Convert BigInt epoch to Date using `epochToDate()` from `@/utils/datetime-utils`
   - Display dates in store/user timezone using `getDateInTz()` from `@/utils/datetime-utils`
   - Convert epoch timestamps from server to Date objects before formatting

**Example Pattern:**

```tsx
// In server action (create/update)
import { getUtcNowEpoch, dateToEpoch, convertStoreTimezoneToUtc } from "@/utils/datetime-utils";

export const createItemAction = storeActionClient
  .schema(createItemSchema)
  .action(async ({ parsedInput, bindArgsClientInputs }) => {
    const storeId = bindArgsClientInputs[0] as string;
    const { name, eventTime } = parsedInput;
    
    // Convert user input date string to UTC Date, then to BigInt epoch
    // eventTime is a string from datetime-local input (e.g., "2024-01-15T14:30")
    const store = await sqlClient.store.findUnique({ where: { id: storeId } });
    const utcDate = convertStoreTimezoneToUtc(eventTime, store.defaultTimezone);
    
    const result = await sqlClient.item.create({
      data: {
        name,
        eventTime: dateToEpoch(utcDate), // ✅ BigInt epoch milliseconds
        createdAt: getUtcNowEpoch(), // ✅ BigInt epoch milliseconds
        updatedAt: getUtcNowEpoch(), // ✅ BigInt epoch milliseconds
      },
    });
    
    return { item: result };
  });
```

```tsx
// In client component (display)
import { epochToDate, getDateInTz } from "@/utils/datetime-utils";
import { format } from "date-fns";

export function ItemDisplay({ item, storeTimezone }: Props) {
  // Convert BigInt epoch to Date, then to store timezone for display
  const epochDate = epochToDate(item.eventTime); // Date | null
  const displayDate = epochDate ? getDateInTz(epochDate, storeTimezone) : null;
  
  return (
    <div>
      {displayDate ? format(displayDate, "yyyy-MM-dd HH:mm") : "N/A"}
    </div>
  );
}
```

**Important Rules:**

- ✅ **DO**: Use `getUtcNowEpoch()` for all timestamps (returns BigInt)
- ✅ **DO**: Convert Date objects to BigInt using `dateToEpoch()` before saving
- ✅ **DO**: Convert BigInt epoch to Date using `epochToDate()` when reading
- ✅ **DO**: Display dates in store/user timezone using `getDateInTz()`
- ❌ **DON'T**: Use `new Date()` directly for database timestamps
- ❌ **DON'T**: Use `Date.now()` directly for database timestamps
- ❌ **DON'T**: Save Date objects directly (must convert to BigInt)
- ❌ **DON'T**: Display BigInt epoch values directly to users

### 6. Filter Implementation

#### 6.1 Filter Component Structure

```typescript
// filter-channel.tsx or filter-observer.tsx
export function Filter({
  selectedStatuses,
  onStatusChange,
  onTitleChange,
  className,
}: FilterProps) {
  const [open, setOpen] = useState(false);
  const [activeTab, setActiveTab] = useState<"status" | "title">("status");
  
  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button variant="outline" className={className}>
          <Filter className="mr-2 h-4 w-4" />
          Filter
          {selectedStatuses.length > 0 && (
            <Badge variant="secondary" className="ml-2">
              {selectedStatuses.length}
            </Badge>
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-[300px] p-0">
        <Tabs defaultValue="status" value={activeTab} onValueChange={(v) => setActiveTab(v as "status" | "title")}>
          <TabsList className="w-full">
            <TabsTrigger value="status" className="flex-1">Status</TabsTrigger>
            <TabsTrigger value="title" className="flex-1">Title</TabsTrigger>
          </TabsList>
          <TabsContent value="status" className="p-2">
            <Command>
              <CommandInput placeholder="Search status..." />
              <CommandList>
                <CommandEmpty>No status found.</CommandEmpty>
                <CommandGroup>
                  {statuses.map((status) => (
                    <CommandItem
                      key={status}
                      onSelect={() => {
                        onStatusChange(
                          selectedStatuses.includes(status)
                            ? selectedStatuses.filter((s) => s !== status)
                            : [...selectedStatuses, status]
                        );
                      }}
                    >
                      <Check
                        className={cn(
                          "mr-2 h-4 w-4",
                          selectedStatuses.includes(status) ? "opacity-100" : "opacity-0"
                        )}
                      />
                      {status}
                    </CommandItem>
                  ))}
                </CommandGroup>
              </CommandList>
            </Command>
          </TabsContent>
          <TabsContent value="title" className="p-2">
            <Input
              placeholder="Search by title..."
              value={titleFilter}
              onChange={(e) => onTitleChange?.(e.target.value)}
            />
          </TabsContent>
        </Tabs>
      </PopoverContent>
    </Popover>
  );
}
```

#### 6.2 Filter State Management

```typescript
// In client component
const [selectedStatuses, setSelectedStatuses] = useState<Status[]>([]);
const [titleFilter, setTitleFilter] = useState("");

const filteredData = useMemo(() => {
  return data.filter((item) => {
    const statusMatch = selectedStatuses.length === 0 || 
                       selectedStatuses.includes(item.status);
    const titleMatch = !titleFilter || 
                      item.title.toLowerCase().includes(titleFilter.toLowerCase()) ||
                      item.etitle?.toLowerCase().includes(titleFilter.toLowerCase());
    return statusMatch && titleMatch;
  });
}, [data, selectedStatuses, titleFilter]);
```

### 7. Settings/Configuration Forms (Single Object Update)

For settings or configuration forms that update a single object (not a list):

```tsx
// Parent component (tabs.tsx or similar)
export const SettingsTabs: React.FC<SettingsProps> = ({
  store,
  settings: initialSettings,
}) => {
  // Manage settings state in client component
  const [settings, setSettings] = useState(initialSettings);

  // Handle updated settings
  const handleSettingsUpdated = (updated: NonNullable<typeof settings>) => {
    setSettings(updated);
  };

  return (
    <SettingsTab
      settings={settings}
      onSettingsUpdated={handleSettingsUpdated}
    />
  );
};

// Form component (tab-settings.tsx)
export const SettingsTab: React.FC<SettingsTabProps> = ({
  settings,
  onSettingsUpdated,
}) => {
  const form = useForm<FormValues>({
    resolver: zodResolver(settingsSchema.omit({ storeId: true })),
    defaultValues: useMemo(() => settings ? { ...settings } : defaults, [settings]),
  });

  // Reset form when settings changes (after update)
  useEffect(() => {
    form.reset(settings ? { ...settings } : defaults);
  }, [settings, form]);

  const onSubmit = async (data: FormValues) => {
    const result = await updateSettingsAction({ 
      storeId: params.storeId, 
      ...data 
    });
    
    if (result?.serverError) {
      toastError({ description: result.serverError });
      return;
    }
    
    // Update local state instead of refreshing router
    const updatedSettings = result.data.settings as SettingsData;
    onSettingsUpdated?.(updatedSettings);
    
    toastSuccess({ description: "Settings updated!" });
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Form fields */}
      </form>
    </Form>
  );
};
```

**Key Points for Settings Forms:**

- Parent component manages the settings state with `useState`
- Form component receives `onSettingsUpdated` callback
- After successful mutation, transform server response and call callback
- Use `useMemo` for `defaultValues` to recalculate when settings change
- Use `useEffect` to reset form when settings prop changes
- **Never use `router.refresh()`** - update state directly via callback

## Summary

- Use local state for table data in client components.
- Use local state for settings/configuration objects in client components.
- Pass mutation callbacks to edit/create/delete components.
- Update the state directly after mutations (arrays or single objects).
- Ensure all required fields are present when adding to state.
- Do not rely on `router.refresh()` for client state updates.
- Only use `router.refresh()` if you need to re-fetch server components.

This pattern ensures a fast, reactive UI and avoids common pitfalls with stale or unsynced data.
