---
description: Fetching data from the API using SWR
globs: 
alwaysApply: true
---
# Data Fetching

There are two ways we fetch data in the app:

1. SWR (default)
2. Server Components

Default to SWR as it makes it easier to refetch data we need.

Here's how we use SWR:

- For API GET requests to server, use the `swr` package
- If we're in a server file, you can fetch the data inline
- For mutating data, use Next.js server actions

## SWR Example

```typescript
const searchParams = useSearchParams();
const page = searchParams.get("page") || "1";
const { data, isLoading, error } = useSWR<PlanHistoryResponse>(
  `/api/user/planned/history?page=${page}`
);
```

## Error Handling

Use `result?.serverError` with `toastError` and `toastSuccess`. Success toast is optional:

```typescript
import { toastError, toastSuccess } from "@/components/Toast";

const onSubmit: SubmitHandler<TestRulesInputs> = useCallback(async (data) => {
  const result = await testAiCustomContentAction({ content: data.message });
  if (result?.serverError) {
    toastError({
      title: "Error testing email",
      description: result?.serverError || "",
    });
  } else {
    toastSuccess({ description: "Saved!" });
  }
}, []);
```

## State Management After Mutations

**Important:** After server action mutations, update local state directly instead of using `router.refresh()`.

### For Lists/Arrays

```typescript
// In parent component
const [data, setData] = useState<ItemType[]>(serverData);

const handleUpdated = (updatedItem: ItemType) => {
  setData(prev => prev.map(item => 
    item.id === updatedItem.id ? updatedItem : item
  ));
};

// In form component
const onSubmit = async (data: FormValues) => {
  const result = await updateItemAction(data);
  if (result?.serverError) {
    toastError({ description: result.serverError });
  } else {
    onUpdated?.(result.data.item); // Update parent state
    toastSuccess({ description: "Updated!" });
  }
};
```

### For Single Objects (Settings/Configuration)

```typescript
// In parent component
const [settings, setSettings] = useState(initialSettings);

const handleSettingsUpdated = (updated: SettingsData) => {
  setSettings(updated);
};

// In form component
const onSubmit = async (data: FormValues) => {
  const result = await updateSettingsAction(data);
  if (result?.serverError) {
    toastError({ description: result.serverError });
  } else {
    onSettingsUpdated?.(result.data.settings); // Update parent state
    toastSuccess({ description: "Updated!" });
  }
};
```

**Never use `router.refresh()` for client state updates** - it causes unnecessary server round-trips and slower UX. Only use `router.refresh()` if you need to re-fetch server components.

## JSON Serialization

**CRITICAL: Always use `transformPrismaDataForJson()` before `JSON.stringify()` when serializing Prisma data.**

Prisma returns `BigInt` for epoch time fields and `Decimal` for decimal fields. These types cannot be serialized directly with `JSON.stringify()`.

- **Always call `transformPrismaDataForJson()`** before `JSON.stringify()` on Prisma query results
- This function converts both `BigInt` (epoch timestamps) and `Decimal` (money amounts) to numbers
- Required for API routes, export functions, and any JSON serialization

**Example:**

```typescript
import { transformPrismaDataForJson } from "@/utils/utils";
import { NextResponse } from "next/server";

// ✅ CORRECT - Transform before JSON.stringify
export async function GET() {
  const facilities = await sqlClient.storeFacility.findMany({});
  
  // Transform BigInt and Decimal to numbers
  transformPrismaDataForJson(facilities);
  
  // Now safe to stringify
  return NextResponse.json(facilities);
}

// ❌ WRONG - Will throw error with BigInt/Decimal
export async function GET() {
  const facilities = await sqlClient.storeFacility.findMany({});
  
  // This will fail if facilities contain BigInt or Decimal
  return NextResponse.json(facilities);
}
```

**For export/download functions:**

```typescript
import { transformPrismaDataForJson } from "@/utils/utils";

export async function POST() {
  const data = await sqlClient.model.findMany({});
  
  // Transform before stringifying
  transformPrismaDataForJson(data);
  
  const jsonContent = JSON.stringify(data, null, 2);
  
  return new NextResponse(jsonContent, {
    headers: {
      "Content-Type": "application/json",
      "Content-Disposition": "attachment; filename=data.json",
    },
  });
}
```
