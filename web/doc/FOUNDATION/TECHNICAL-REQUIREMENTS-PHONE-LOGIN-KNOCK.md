# Technical Requirements: Phone Login with Knock

**Date:** 2025-01-27  
**Status:** Active  
**Version:** 1.1

**Related Documents:**

* [PHONE-LOGIN-KNOCK.md](./PHONE-LOGIN-KNOCK.md) - Functional Requirements
* [SECURITY.md](../SECURITY.md)
* [ENVIRONMENT_VARIABLES.md](../ENVIRONMENT_VARIABLES.md)

***

## 1. Overview

This document specifies the technical architecture, implementation patterns, and technical constraints for phone number-based authentication using Knock as the SMS/OTP provider. It complements the Functional Requirements document by providing technical implementation details.

The phone authentication system integrates with Better Auth's `phoneNumber` plugin and uses Knock's API for OTP generation, delivery, and verification.

***

## 2. Architecture

### 2.1 Technology Stack

* **Framework:** Next.js 15 (App Router)
* **Language:** TypeScript
* **Database:** PostgreSQL (via Prisma ORM)
* **Authentication:** Better Auth with `phoneNumber` plugin
* **SMS/OTP Provider:** Knock (<https://knock.app>)
* **Knock SDK:** `@knocklabs/node`
* **Validation:** Zod v4
* **State Management:** React Server Components (default), Client Components with local state
* **Data Fetching:** SWR (client-side), Server Components (server-side)
* **UI Framework:** React 19, Tailwind CSS v4, shadcn/ui, Radix UI
* **Icons:** @tabler/icons-react
* **Package Manager:** Bun
* **Phone Number Validation:** `libphonenumber-js` (recommended)

### 2.2 Application Architecture

#### 2.2.1 Server Actions Pattern

All phone authentication-related data mutations use Next.js Server Actions with `next-safe-action` wrapper:

```typescript
// Pattern: actions/auth/phone/[action-name].ts
export const [actionName]Action = [actionClient]
  .metadata({ name: "[actionName]" })
  .schema([validationSchema])
  .action(async ({ parsedInput, ctx }) => {
    // Implementation
  });
```

**Action Client Types:**

* `baseClient` - For public/unauthenticated actions (e.g., send OTP, verify OTP for sign up/sign in)
* `userRequiredActionClient` - For authenticated user actions (e.g., link phone number, update phone number)
* `adminActionClient` - For system admin actions (e.g., view authentication logs)

#### 2.2.2 Component Architecture

* **Server Components (default):** Account settings pages, authentication pages (initial render)
* **Client Components:** Phone input forms, OTP verification forms, authentication flows
* **Pattern:** Server page → Client component → Server actions → Knock API

#### 2.2.3 Authentication Flow Architecture

1. **OTP Request:** Client component calls server action → Server action calls Knock API → OTP sent via SMS
2. **OTP Verification:** Client component calls server action → Server action calls Knock API → Better Auth creates session
3. **State Updates:** Client components update local state after successful authentication

#### 2.2.4 Knock Integration Architecture

```txt
┌─────────────┐
│   Client    │
│  Component  │
└──────┬──────┘
       │
       │ Server Action
       ▼
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│   Better    │─────▶│    Knock    │─────▶│     SMS     │
│    Auth     │      │     API     │      │   Delivery  │
└─────────────┘      └─────────────┘      └─────────────┘
       │
       │ Session Creation
       ▼
┌─────────────┐
│  Database   │
│  (Prisma)   │
└─────────────┘
```

***

## 3. Database Schema

### 3.1 User Model

The `User` model already includes phone number fields:

```prisma
model User {
  id                    String   @id @default(cuid())
  phoneNumber           String?  // E.164 format (e.g., +886912345678)
  phoneNumberVerified   Boolean? @default(false)
  // ... other fields
}
```

**Field Specifications:**

* `phoneNumber` (String, optional):
  * Format: E.164 international format (e.g., `+886912345678`)
  * Stored in normalized format (no spaces, dashes, or parentheses)
  * Indexed for fast lookup
  * Unique constraint (one phone number per user)
  * Encrypted at rest (if encryption is enabled)

* `phoneNumberVerified` (Boolean, default: false):
  * Indicates whether phone number has been verified via OTP
  * Set to `true` after successful OTP verification
  * Set to `false` when phone number is updated (until new number is verified)

### 3.2 OTP Storage (Temporary)

OTP codes are **NOT stored in the database**. Instead:

* **Knock manages OTP lifecycle:**
  * OTP codes are generated by Knock
  * OTP codes are stored temporarily by Knock
  * OTP codes are verified via Knock API
  * OTP codes expire automatically (default: 10 minutes)

* **Local tracking (optional, in-memory cache):**
  * Can use Redis or in-memory cache to track OTP send attempts
  * Used for rate limiting per phone number
  * Not required if Knock handles rate limiting

### 3.3 Audit Log Model (Optional)

For security and compliance, consider adding an audit log model:

```prisma
model PhoneAuthAuditLog {
  id              String   @id @default(cuid())
  eventType       String   // "OTP_SEND", "OTP_VERIFY", "SIGN_UP", "SIGN_IN", "PHONE_UPDATE"
  userId          String?   // Null for sign up attempts
  phoneNumber     String   // Masked: +886****5678
  ipAddress       String?
  userAgent       String?
  success         Boolean
  errorMessage    String?
  metadata        String?  // JSON string for additional data
  createdAt       BigInt   // Epoch milliseconds
  
  @@index([userId])
  @@index([phoneNumber])
  @@index([createdAt])
  @@index([eventType])
  @@map("phone_auth_audit_log")
}
```

**Note:** This is optional and can be added in Phase 2 or Phase 3 of implementation.

***

## 4. Knock API Integration

### 4.1 Knock SDK Setup

**Installation:**

```bash
bun add @knocklabs/node @knocklabs/react
```

**Environment Variables:**

```env
# Knock API Configuration
KNOCK_API_KEY=sk_test_... # Knock API key (required)
KNOCK_WORKFLOW_KEY=phone-otp # Knock workflow key for OTP (required)
KNOCK_API_URL=https://api.knock.app # Optional, defaults to production
```

### 4.2 Knock Client Initialization

**File:** `src/lib/knock/client.ts`

```typescript
import Knock from "@knocklabs/node";

if (!process.env.KNOCK_API_KEY) {
  throw new Error("KNOCK_API_KEY environment variable is required");
}

export const knockClient = new Knock({
  apiKey: process.env.KNOCK_API_KEY,
});
```

### 4.3 Knock Workflow Configuration

**Workflow Setup in Knock Dashboard:**

#### Step 1: Access Knock Dashboard

1. Log in to your Knock account at <https://app.knock.app>
2. Navigate to your project (or create a new project if needed)
3. Go to **Workflows** in the left sidebar

#### Step 2: Create New Workflow

1. Click **"Create workflow"** or **"New workflow"** button
2. Enter workflow key: `phone-otp` (or match your `KNOCK_WORKFLOW_KEY` environment variable)
3. Enter workflow name: "Phone OTP Verification"
4. Click **"Create workflow"**

#### Step 3: Configure Workflow Steps

1. **Add SMS Channel:**
   * Click **"Add step"** or **"Add channel"**
   * Select **"SMS"** as the channel
   * Configure SMS provider (Twilio, AWS SNS, etc.) if not already configured

2. **Configure SMS Template:**
   * Click on the SMS step to edit
   * In the message template editor, enter:

``` txt
Your riben.life verification code is: {{otp_code}}
This code will expire in 10 minutes.
Do not share this code with anyone.
```

* **Template Variables:**
  * `{{otp_code}}` - The 6-digit OTP code (will be passed in workflow data)
  * `{{phone_number}}` - The recipient's phone number (optional, for reference)
  * `{{expires_in_minutes}}` - Expiration time (optional, if passed in data)

1. **Save the workflow**

#### Step 4: Configure SMS Provider (if not already done)

1. Go to **Settings** → **Channels** → **SMS**
2. Select your SMS provider (Twilio, AWS SNS, etc.)
3. Enter API credentials:
   * **Twilio:**
     * Account SID
     * Auth Token
     * From phone number (sender ID)
   * **AWS SNS:**
     * AWS Access Key ID
     * AWS Secret Access Key
     * Region
4. Test SMS delivery to verify configuration

#### Step 5: Test the Workflow

1. Go back to the workflow
2. Click **"Test workflow"** or **"Send test"**
3. Enter test phone number (your own number for testing)
4. Enter test data:

   ```json
   {
     "otp_code": "123456",
     "phone_number": "+886912345678",
     "expires_in_minutes": 10
   }
   ```

5. Verify you receive the SMS with the OTP code

#### Step 6: Set Workflow Key in Environment Variables

Add to your `.env` file:

```env
KNOCK_WORKFLOW_KEY=phone-otp
```

**Alternative SMS Template Examples:**

**English:**

```
Your riben.life verification code is: {{otp_code}}
Valid for 10 minutes. Do not share this code.
```

**Traditional Chinese:**

```
您的 riben.life 驗證碼是：{{otp_code}}
有效期 10 分鐘。請勿與他人分享此驗證碼。
```

**Simplified Chinese:**

```
您的 riben.life 验证码是：{{otp_code}}
有效期 10 分钟。请勿与他人分享此验证码。
```

**Note:** For multi-language support, you may need to:

1. Create separate workflows per language (e.g., `phone-otp-en`, `phone-otp-tw`)
2. Or use Knock's localization features (if available)
3. Or pass the language in workflow data and use conditional logic in the template

### 4.4 Send OTP Implementation

**File:** `src/lib/knock/send-otp.ts`

```typescript
import { knockClient } from "./client";
import logger from "@/lib/logger";

export interface SendOTPParams {
  phoneNumber: string; // E.164 format
  userId?: string; // Optional, for existing users
}

export interface SendOTPResult {
  success: boolean;
  messageId?: string;
  error?: string;
}

export async function sendOTP({
  phoneNumber,
  userId,
}: SendOTPParams): Promise<SendOTPResult> {
  try {
    const workflowKey = process.env.KNOCK_WORKFLOW_KEY || "phone-otp";
    
    // Generate OTP code (6 digits)
    const otpCode = generateOTPCode();
    
    // Trigger Knock workflow
    const result = await knockClient.workflows.trigger(workflowKey, {
      recipients: [phoneNumber],
      data: {
        otp_code: otpCode,
        phone_number: phoneNumber,
        expires_in_minutes: 10,
      },
    });
    
    logger.info("OTP sent via Knock", {
      metadata: {
        phoneNumber: maskPhoneNumber(phoneNumber),
        userId,
        messageId: result.message_id,
      },
      tags: ["knock", "otp", "send"],
    });
    
    return {
      success: true,
      messageId: result.message_id,
    };
  } catch (error) {
    logger.error("Failed to send OTP via Knock", {
      metadata: {
        phoneNumber: maskPhoneNumber(phoneNumber),
        userId,
        error: error instanceof Error ? error.message : String(error),
      },
      tags: ["knock", "otp", "error"],
    });
    
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to send OTP",
    };
  }
}
```

**Important:** Knock does not have a built-in OTP verification API. We need to:

1. Generate OTP codes locally
2. Store them temporarily in the database
3. Verify them by comparing with stored codes

### 4.5 OTP Storage Setup

Since Knock only handles SMS delivery (not OTP verification), we store OTP codes in the database for verification.

**Database Storage Implementation**

Create a Prisma model for OTP storage:

```prisma
model PhoneOTP {
  id          String   @id @default(uuid())
  phoneNumber String   // E.164 format, indexed
  code        String   // Hashed OTP code
  expiresAt   BigInt   // Epoch milliseconds
  attempts    Int      @default(0)
  createdAt   BigInt   // Epoch milliseconds
  
  @@unique([phoneNumber])
  @@index([phoneNumber])
  @@index([expiresAt])
  @@map("phone_otp")
}
```

**Implementation File:** `src/lib/knock/otp-db.ts`

The database storage implementation provides:

* `storeOTP()` - Stores OTP code with expiration
* `verifyOTP()` - Verifies code, checks expiration and attempt limits
* `cleanupExpiredOTPs()` - Cleanup function for expired OTPs (can be run via cron)

### 4.6 Verify OTP Implementation

**File:** `src/lib/knock/verify-otp.ts`

```typescript
import { verifyOTP as verifyStoredOTP } from "./otp-db";
import logger from "@/lib/logger";
import { maskPhoneNumber } from "@/utils/utils";

export interface VerifyOTPParams {
  phoneNumber: string; // E.164 format
  code: string; // 6-digit OTP code
}

export interface VerifyOTPResult {
  valid: boolean;
  error?: string;
}

export async function verifyOTP({
  phoneNumber,
  code,
}: VerifyOTPParams): Promise<VerifyOTPResult> {
  try {
    // Verify OTP against stored code in database (Knock doesn't provide verification API)
    const isValid = await verifyStoredOTP(phoneNumber, code);
    
    if (!isValid) {
      logger.warn("OTP verification failed", {
        metadata: {
          phoneNumber: maskPhoneNumber(phoneNumber),
          codeLength: code.length,
        },
        tags: ["knock", "otp", "verify", "failed"],
      });
      
      return {
        valid: false,
        error: "Invalid or expired OTP code. Please request a new code.",
      };
    }
    
    logger.info("OTP verification successful", {
      metadata: {
        phoneNumber: maskPhoneNumber(phoneNumber),
      },
      tags: ["knock", "otp", "verify", "success"],
    });
    
    return {
      valid: true,
    };
  } catch (error) {
    logger.error("Failed to verify OTP", {
      metadata: {
        phoneNumber: maskPhoneNumber(phoneNumber),
        error: error instanceof Error ? error.message : String(error),
      },
      tags: ["knock", "otp", "error"],
    });
    
    return {
      valid: false,
      error: error instanceof Error ? error.message : "Failed to verify OTP",
    };
  }
}

```

**Important:** Since Knock doesn't provide OTP verification, we store OTP codes in the database and verify them by comparison.

**Update sendOTP to store OTP:**

```typescript
// In send-otp.ts, after generating OTP code:
import { storeOTP } from "./otp-db";

// After triggering workflow:
storeOTP(phoneNumber, otpCode, 10); // Store for 10 minutes
```

### 4.6 Error Handling

**Knock API Error Types:**

* **Network Errors:** Retry with exponential backoff
* **Invalid API Key:** Log error, disable phone auth
* **Rate Limit Exceeded:** Return rate limit error to user
* **Service Unavailable:** Graceful degradation
* **Invalid Phone Number:** Return validation error

**Error Handling Pattern:**

```typescript
import { knockClient } from "./client";
import logger from "@/lib/logger";

async function handleKnockError(error: unknown): Promise<string> {
  if (error instanceof Error) {
    // Check for specific Knock error types
    if (error.message.includes("rate limit")) {
      return "Too many requests. Please try again later.";
    }
    if (error.message.includes("invalid phone")) {
      return "Invalid phone number format.";
    }
    if (error.message.includes("unauthorized")) {
      logger.error("Knock API key invalid", { metadata: { error: error.message } });
      return "SMS service temporarily unavailable. Please try again later.";
    }
  }
  
  logger.error("Knock API error", {
    metadata: { error: error instanceof Error ? error.message : String(error) },
  });
  
  return "Failed to send SMS. Please try again later.";
}
```

***

## 5. Better Auth Integration

### 5.1 Better Auth Configuration

**File:** `src/lib/auth.ts`

Update the `phoneNumber` plugin configuration:

```typescript
import { phoneNumber } from "better-auth/plugins";
import { sendOTP } from "@/lib/knock/send-otp";
import { verifyOTP } from "@/lib/knock/verify-otp";

export const auth = betterAuth({
  // ... other configuration
  plugins: [
    // ... other plugins
    phoneNumber({
      sendOTP: async ({ phoneNumber, code }, ctx) => {
        // Send OTP via Knock
        const result = await sendOTP({ phoneNumber });
        if (!result.success) {
          throw new Error(result.error || "Failed to send OTP");
        }
      },
      verifyOTP: async ({ phoneNumber, code }, ctx) => {
        // Verify OTP via Knock
        const result = await verifyOTP({ phoneNumber, code });
        return result.valid;
      },
    }),
    // ... other plugins
  ],
  user: {
    additionalFields: {
      phoneNumber: {
        type: "string",
        required: false,
        defaultValue: "",
      },
      phoneNumberVerified: {
        type: "boolean",
        required: false,
        defaultValue: false,
      },
      // ... other fields
    },
  },
});
```

### 5.2 Better Auth Phone Authentication Methods

Better Auth's `phoneNumber` plugin provides HTTP endpoints for phone authentication. Server actions use these endpoints via HTTP requests:

* `/api/auth/phone/sign-up` - Sign up with phone number (POST)
* `/api/auth/phone/sign-in` - Sign in with phone number (POST)

**Note:** The server actions (`signInPhoneAction`, `signUpPhoneAction`) automatically handle both sign-up and sign-in. If a user doesn't exist, the system signs them up first, then signs them in. If the user exists, it just signs them in.

**Server Action Usage:**

```typescript
"use server";

// Combined sign-in/sign-up action
import { signInPhoneAction } from "@/actions/auth/phone/sign-in-phone";

// This action works for both new and existing users
const result = await signInPhoneAction({
  phoneNumber: "+886912345678",
  code: "123456",
});

if (result?.data) {
  const { isNewUser, user, session } = result.data;
  // isNewUser indicates if account was just created
}
```

**Client-side Usage (Better Auth Client):**

```typescript
"use client";

import { authClient } from "@/lib/auth-client";

// Send OTP
const { data, error } = await authClient.signInPhone.sendOTP({
  phoneNumber: "+886912345678",
});

// Verify OTP and authenticate (sign up if new, sign in if existing)
const { data: session, error: verifyError } = await authClient.signInPhone.verifyOTP({
  phoneNumber: "+886912345678",
  code: "123456",
});
```

### 5.3 Account Linking

Better Auth supports account linking for users with multiple authentication methods:

* Users can link phone number to existing email account
* Users can link email to existing phone account
* Account linking follows Better Auth's `accountLinking` configuration

**Configuration:**

```typescript
export const auth = betterAuth({
  account: {
    accountLinking: {
      enabled: true,
      allowDifferentEmails: true,
      trustedProviders: ["google", "line", "apple", "phone"],
    },
  },
  // ... other configuration
});
```

***

## 6. Server Actions

### 6.1 Send OTP Action

**File:** `src/actions/auth/phone/send-otp.ts`

```typescript
"use server";

import { z } from "zod";
import { baseClient } from "@/utils/actions/safe-action";
import { sendOTP } from "@/lib/knock/send-otp";
import { normalizePhoneNumber, validatePhoneNumber } from "@/utils/phone-utils";
import { checkRateLimit } from "@/utils/rate-limit";

const sendOTPSchema = z.object({
  phoneNumber: z.string().min(1, "Phone number is required"),
});

export const sendOTPAction = baseClient
  .metadata({ name: "sendOTP" })
  .schema(sendOTPSchema)
  .action(async ({ parsedInput, ctx }) => {
    const { phoneNumber } = parsedInput;
    
    // Normalize phone number to E.164 format
    const normalizedPhone = normalizePhoneNumber(phoneNumber);
    
    // Validate phone number format
    const isValid = validatePhoneNumber(normalizedPhone);
    if (!isValid) {
      return {
        serverError: "Invalid phone number format. Please use international format (e.g., +886912345678).",
      };
    }
    
    // Check rate limit
    const ipAddress = ctx?.ipAddress || "unknown";
    const rateLimitResult = await checkRateLimit({
      phoneNumber: normalizedPhone,
      ipAddress,
    });
    
    if (!rateLimitResult.allowed) {
      return {
        serverError: rateLimitResult.message || "Too many requests. Please try again later.",
      };
    }
    
    // Send OTP via Knock
    const result = await sendOTP({ phoneNumber: normalizedPhone });
    
    if (!result.success) {
      return {
        serverError: result.error || "Failed to send OTP. Please try again later.",
      };
    }
    
    return {
      data: {
        success: true,
        message: "OTP code sent successfully.",
      },
    };
  });
```

### 6.2 Combined Sign In/Sign Up Action

**Files:**

* `src/actions/auth/phone/sign-in-phone.ts` (primary action)
* `src/actions/auth/phone/sign-up-phone.ts` (backward compatibility, uses same logic)
* `src/actions/auth/phone/sign-in-or-up-phone.ts` (explicit combined action)

**Note:** All three actions use the same combined logic. The system automatically handles both sign-up and sign-in based on whether the user exists.

```typescript
"use server";

import { z } from "zod";
import { baseClient } from "@/utils/actions/safe-action";
import { auth } from "@/lib/auth";
import { verifyOTP } from "@/lib/knock/verify-otp";
import { normalizePhoneNumber, validatePhoneNumber } from "@/utils/phone-utils";
import { sqlClient } from "@/lib/prismadb";
import { headers } from "next/headers";

const signInPhoneSchema = z.object({
  phoneNumber: z.string().min(1, "Phone number is required"),
  code: z.string().length(6, "OTP code must be 6 digits"),
});

/**
 * Combined sign-in/sign-up action.
 * If user doesn't exist, signs up first, then signs in.
 * If user exists, just signs in.
 */
export const signInPhoneAction = baseClient
  .metadata({ name: "signInPhone" })
  .schema(signInPhoneSchema)
  .action(async ({ parsedInput, ctx }) => {
    const { phoneNumber, code } = parsedInput;

    // Normalize phone number
    const normalizedPhone = normalizePhoneNumber(phoneNumber);

    // Validate phone number format
    const isValid = validatePhoneNumber(normalizedPhone);
    if (!isValid) {
      return {
        serverError: "Invalid phone number format.",
      };
    }

    // Verify OTP first (before checking user existence)
    const verifyResult = await verifyOTP({
      phoneNumber: normalizedPhone,
      code,
    });

    if (!verifyResult.valid) {
      return {
        serverError: verifyResult.error || "Invalid OTP code. Please try again.",
      };
    }

    // Check if phone number is registered
    const existingUser = await sqlClient.user.findFirst({
      where: { phoneNumber: normalizedPhone },
    });

    const headersList = await headers();
    const baseURL =
      process.env.NEXT_PUBLIC_BASE_URL ||
      process.env.NEXT_PUBLIC_API_URL ||
      (process.env.NODE_ENV === "production"
        ? "https://riben.life"
        : "http://localhost:3001");

    try {
      // If user doesn't exist, sign up first
      if (!existingUser) {
        // Make HTTP request to Better Auth's phone sign-up endpoint
        const signUpResponse = await fetch(`${baseURL}/api/auth/phone/sign-up`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Cookie: headersList.get("cookie") || "",
          },
          body: JSON.stringify({
            phoneNumber: normalizedPhone,
            code,
          }),
        });

        if (!signUpResponse.ok) {
          const errorData = await signUpResponse.json().catch(() => ({}));
          return {
            serverError:
              errorData.message || "Failed to create account. Please try again.",
          };
        }
      }

      // Sign in (works for both new and existing users)
      const signInResponse = await fetch(`${baseURL}/api/auth/phone/sign-in`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Cookie: headersList.get("cookie") || "",
        },
        body: JSON.stringify({
          phoneNumber: normalizedPhone,
          code,
        }),
      });

      if (!signInResponse.ok) {
        const errorData = await signInResponse.json().catch(() => ({}));
        return {
          serverError:
            errorData.message || "Failed to sign in. Please try again.",
        };
      }

      // Get the session after sign in
      const session = await auth.api.getSession({
        headers: headersList,
      });

      return {
        data: {
          success: true,
          isNewUser: !existingUser, // Flag indicating if account was just created
          user: session?.user,
          session: session?.session,
        },
      };
    } catch (error) {
      return {
        serverError:
          error instanceof Error
            ? error.message
            : "Failed to authenticate. Please try again.",
      };
    }
  });
```

**Key Features:**

1. **Unified Flow:** Single action handles both sign-up and sign-in
2. **Automatic Detection:** System checks if user exists and handles accordingly
3. **Seamless UX:** Users don't need to know if they're registered or not
4. **Response Flag:** Returns `isNewUser` to indicate if account was just created
5. **Backward Compatible:** `signUpPhoneAction` and `signInPhoneAction` both work the same way

### 6.4 Link Phone Number Action

**File:** `src/actions/auth/phone/link-phone.ts`

```typescript
"use server";

import { z } from "zod";
import { userRequiredActionClient } from "@/utils/actions/safe-action";
import { verifyOTP } from "@/lib/knock/verify-otp";
import { normalizePhoneNumber, validatePhoneNumber } from "@/utils/phone-utils";
import { sqlClient } from "@/lib/prismadb";
import { getUtcNowEpoch } from "@/utils/datetime-utils";

const linkPhoneSchema = z.object({
  phoneNumber: z.string().min(1, "Phone number is required"),
  code: z.string().length(6, "OTP code must be 6 digits"),
});

export const linkPhoneAction = userRequiredActionClient
  .metadata({ name: "linkPhone" })
  .schema(linkPhoneSchema)
  .action(async ({ parsedInput, ctx }) => {
    const { phoneNumber, code } = parsedInput;
    const userId = ctx?.userId;
    
    if (!userId) {
      return {
        serverError: "User not authenticated.",
      };
    }
    
    // Normalize phone number
    const normalizedPhone = normalizePhoneNumber(phoneNumber);
    
    // Validate phone number format
    const isValid = validatePhoneNumber(normalizedPhone);
    if (!isValid) {
      return {
        serverError: "Invalid phone number format.",
      };
    }
    
    // Check if phone number is already registered to another user
    const existingUser = await sqlClient.user.findFirst({
      where: {
        phoneNumber: normalizedPhone,
        NOT: { id: userId },
      },
    });
    
    if (existingUser) {
      return {
        serverError: "This phone number is already registered to another account.",
      };
    }
    
    // Verify OTP via Knock
    const verifyResult = await verifyOTP({
      phoneNumber: normalizedPhone,
      code,
    });
    
    if (!verifyResult.valid) {
      return {
        serverError: verifyResult.error || "Invalid OTP code. Please try again.",
      };
    }
    
    // Update user's phone number
    const now = getUtcNowEpoch();
    await sqlClient.user.update({
      where: { id: userId },
      data: {
        phoneNumber: normalizedPhone,
        phoneNumberVerified: true,
        updatedAt: new Date(now.toString()),
      },
    });
    
    return {
      data: {
        success: true,
        phoneNumber: normalizedPhone,
        verified: true,
      },
    };
  });
```

### 6.5 Update Phone Number Action

**File:** `src/actions/auth/phone/update-phone.ts`

Similar to `linkPhoneAction`, but requires verification of new phone number and optionally notifies old phone number.

***

## 7. Rate Limiting

### 7.1 Rate Limiting Strategy

**Per Phone Number:**

* Maximum 3 OTP requests per 15 minutes
* Maximum 5 OTP requests per hour
* Maximum 10 OTP requests per 24 hours

**Per IP Address:**

* Maximum 10 OTP requests per 15 minutes
* Maximum 20 OTP requests per hour
* Maximum 50 OTP requests per 24 hours

### 7.2 Rate Limiting Implementation

**File:** `src/utils/rate-limit.ts`

```typescript
import { sqlClient } from "@/lib/prismadb";
import logger from "@/lib/logger";

interface RateLimitCheck {
  phoneNumber?: string;
  ipAddress?: string;
}

interface RateLimitResult {
  allowed: boolean;
  message?: string;
  retryAfter?: number; // seconds
}

// In-memory cache for rate limiting (or use Redis in production)
const rateLimitCache = new Map<string, number[]>();

export async function checkRateLimit({
  phoneNumber,
  ipAddress,
}: RateLimitCheck): Promise<RateLimitResult> {
  const now = Date.now();
  const windows = [
    { duration: 15 * 60 * 1000, max: 3 }, // 15 minutes, 3 requests
    { duration: 60 * 60 * 1000, max: 5 }, // 1 hour, 5 requests
    { duration: 24 * 60 * 60 * 1000, max: 10 }, // 24 hours, 10 requests
  ];
  
  // Check phone number rate limit
  if (phoneNumber) {
    const phoneKey = `phone:${phoneNumber}`;
    const phoneRequests = rateLimitCache.get(phoneKey) || [];
    
    for (const window of windows) {
      const recentRequests = phoneRequests.filter(
        (timestamp) => now - timestamp < window.duration
      );
      
      if (recentRequests.length >= window.max) {
        const oldestRequest = Math.min(...recentRequests);
        const retryAfter = Math.ceil((oldestRequest + window.duration - now) / 1000);
        
        logger.warn("Phone number rate limit exceeded", {
          metadata: {
            phoneNumber: maskPhoneNumber(phoneNumber),
            window: `${window.duration}ms`,
            max: window.max,
            current: recentRequests.length,
          },
          tags: ["rate-limit", "phone"],
        });
        
        return {
          allowed: false,
          message: `Too many requests. Please try again in ${retryAfter} seconds.`,
          retryAfter,
        };
      }
    }
    
    // Add current request
    phoneRequests.push(now);
    rateLimitCache.set(phoneKey, phoneRequests);
    
    // Clean up old entries
    cleanupCache(phoneKey, phoneRequests);
  }
  
  // Check IP address rate limit
  if (ipAddress) {
    const ipKey = `ip:${ipAddress}`;
    const ipRequests = rateLimitCache.get(ipKey) || [];
    const ipWindows = [
      { duration: 15 * 60 * 1000, max: 10 },
      { duration: 60 * 60 * 1000, max: 20 },
      { duration: 24 * 60 * 60 * 1000, max: 50 },
    ];
    
    for (const window of ipWindows) {
      const recentRequests = ipRequests.filter(
        (timestamp) => now - timestamp < window.duration
      );
      
      if (recentRequests.length >= window.max) {
        const oldestRequest = Math.min(...recentRequests);
        const retryAfter = Math.ceil((oldestRequest + window.duration - now) / 1000);
        
        logger.warn("IP address rate limit exceeded", {
          metadata: {
            ipAddress,
            window: `${window.duration}ms`,
            max: window.max,
            current: recentRequests.length,
          },
          tags: ["rate-limit", "ip"],
        });
        
        return {
          allowed: false,
          message: `Too many requests. Please try again in ${retryAfter} seconds.`,
          retryAfter,
        };
      }
    }
    
    // Add current request
    ipRequests.push(now);
    rateLimitCache.set(ipKey, ipRequests);
    
    // Clean up old entries
    cleanupCache(ipKey, ipRequests);
  }
  
  return { allowed: true };
}

function cleanupCache(key: string, requests: number[]): void {
  const now = Date.now();
  const maxAge = 24 * 60 * 60 * 1000; // 24 hours
  const filtered = requests.filter((timestamp) => now - timestamp < maxAge);
  
  if (filtered.length === 0) {
    rateLimitCache.delete(key);
  } else {
    rateLimitCache.set(key, filtered);
  }
}

function maskPhoneNumber(phoneNumber: string): string {
  if (phoneNumber.length <= 4) return "****";
  return phoneNumber.slice(0, -4) + "****";
}
```

**Note:** For production, consider using Redis for distributed rate limiting across multiple servers.

***

## 8. Phone Number Validation

### 8.1 Phone Number Utilities

**File:** `src/utils/phone-utils.ts`

```typescript
import { parsePhoneNumber, isValidPhoneNumber } from "libphonenumber-js";

/**
 * Normalize phone number to E.164 format
 * @param phoneNumber - Phone number in any format
 * @returns Normalized phone number in E.164 format (e.g., +886912345678)
 */
export function normalizePhoneNumber(phoneNumber: string): string {
  try {
    // Remove spaces, dashes, parentheses
    const cleaned = phoneNumber.replace(/[\s\-\(\)]/g, "");
    
    // Parse and normalize to E.164
    const parsed = parsePhoneNumber(cleaned);
    return parsed.number; // Returns E.164 format (e.g., +886912345678)
  } catch (error) {
    // If parsing fails, try to add + prefix if missing
    if (!phoneNumber.startsWith("+")) {
      return `+${phoneNumber}`;
    }
    return phoneNumber;
  }
}

/**
 * Validate phone number format
 * @param phoneNumber - Phone number in E.164 format
 * @returns true if valid, false otherwise
 */
export function validatePhoneNumber(phoneNumber: string): boolean {
  try {
    return isValidPhoneNumber(phoneNumber);
  } catch (error) {
    return false;
  }
}

/**
 * Format phone number for display (user-friendly format)
 * @param phoneNumber - Phone number in E.164 format
 * @returns Formatted phone number (e.g., +886 912 345 678)
 */
export function formatPhoneNumber(phoneNumber: string): string {
  try {
    const parsed = parsePhoneNumber(phoneNumber);
    return parsed.formatInternational(); // Returns +886 912 345 678
  } catch (error) {
    return phoneNumber;
  }
}

/**
 * Mask phone number for privacy (e.g., +886****5678)
 * @param phoneNumber - Phone number in E.164 format
 * @returns Masked phone number
 */
export function maskPhoneNumber(phoneNumber: string): string {
  if (phoneNumber.length <= 4) return "****";
  return phoneNumber.slice(0, -4) + "****";
}
```

**Installation:**

```bash
bun add libphonenumber-js
```

***

## 9. Error Handling

### 9.1 Error Types

**Validation Errors:**

* Invalid phone number format
* Phone number already registered
* Phone number not registered
* Invalid OTP code
* OTP code expired

**Rate Limiting Errors:**

* Too many OTP requests
* Rate limit exceeded

**Knock API Errors:**

* Network errors
* Invalid API key
* Service unavailable
* SMS delivery failure

**Better Auth Errors:**

* Account creation failure
* Session creation failure
* Account linking failure

### 9.2 Error Handling Pattern

All server actions return:

```typescript
{
  data?: T;           // Success data
  serverError?: string; // Error message
  validationErrors?: {  // Validation errors
    [field: string]: string[];
  };
}
```

**Client-side Error Handling:**

```typescript
"use client";

const result = await sendOTPAction({ phoneNumber });

if (result?.serverError) {
  toastError({ description: result.serverError });
  return;
}

if (result?.validationErrors) {
  // Handle validation errors
  Object.entries(result.validationErrors).forEach(([field, errors]) => {
    form.setError(field, { message: errors[0] });
  });
  return;
}

// Success
toastSuccess({ description: "OTP sent successfully!" });
```

***

## 10. Security Requirements

### 10.1 OTP Security

* **OTP Generation:** Cryptographically random, 6 digits
* **OTP Storage:** Not stored in database (managed by Knock)
* **OTP Expiration:** 10 minutes (configurable)
* **OTP Single-Use:** Invalidated after successful verification
* **OTP Attempt Limits:** Maximum 5 attempts per code

### 10.2 Phone Number Security

* **Encryption at Rest:** Phone numbers encrypted in database (if encryption enabled)
* **Masking in UI:** Phone numbers masked in UI and logs (e.g., +886****5678)
* **Access Control:** Only user and admins can view phone numbers
* **Data Protection:** Compliant with GDPR, CCPA, and other regulations

### 10.3 Rate Limiting Security

* **Per Phone Number:** Prevents abuse of OTP requests
* **Per IP Address:** Prevents distributed attacks
* **Violation Logging:** All rate limit violations logged
* **Account Lockout:** Optional account lockout after repeated failures

### 10.4 API Security

* **API Key Protection:** Knock API keys stored in environment variables
* **HTTPS Only:** All API requests over HTTPS
* **Input Validation:** All inputs validated with Zod schemas
* **SQL Injection Prevention:** Prisma ORM with parameterized queries

***

## 11. Performance Requirements

### 11.1 Response Times

* **OTP Send:** < 5 seconds (Knock API: < 2s, SMS delivery: < 3s)
* **OTP Verify:** < 2 seconds (Knock API: < 1s, Database: < 1s)
* **Sign Up/Sign In:** < 3 seconds (including OTP verification)
* **Phone Number Update:** < 3 seconds

### 11.2 Database Optimization

* **Indexes:** `phoneNumber` field indexed for fast lookup
* **Query Optimization:** Use `select` to limit returned fields
* **Connection Pooling:** Prisma connection pooling enabled

### 11.3 Caching

* **Rate Limit Cache:** In-memory cache (or Redis for production)
* **Phone Number Lookup:** Optional caching for frequently accessed phone numbers

***

## 12. Implementation Phases

### Phase 1: Basic Phone Authentication (MVP)

**Tasks:**

1. Install Knock SDK: `bun add @knocklabs/node`
2. Install phone validation library: `bun add libphonenumber-js`
3. Create Knock client (`src/lib/knock/client.ts`)
4. Implement `sendOTP` function (`src/lib/knock/send-otp.ts`)
5. Implement `verifyOTP` function (`src/lib/knock/verify-otp.ts`)
6. Update Better Auth configuration (`src/lib/auth.ts`)
7. Create phone number utilities (`src/utils/phone-utils.ts`)
8. Create server actions:
   * `send-otp.ts`
   * `sign-in-phone.ts` (combined sign-in/sign-up logic)
   * `sign-up-phone.ts` (backward compatibility, uses same logic)
   * `sign-in-or-up-phone.ts` (explicit combined action)
9. Create UI components:
   * Phone input form
   * OTP verification form
   * Sign up/sign in pages
10. Basic error handling
11. Basic rate limiting

**Deliverables:**

* Users can authenticate with phone number (automatic sign-up if new, sign-in if existing)
* Seamless UX - users don't need to know if they're registered
* OTP codes sent via Knock SMS
* OTP codes verified against database storage

### Phase 2: Enhanced Features

**Tasks:**

1. Implement rate limiting (`src/utils/rate-limit.ts`)
2. Create `link-phone.ts` action
3. Create `update-phone.ts` action
4. Add phone number management to account settings
5. Enhanced error handling
6. Audit logging (optional)
7. Account linking UI

**Deliverables:**

* Phone number verification in account settings
* Phone number update functionality
* Account linking (phone + email)
* Rate limiting enforcement
* Enhanced error messages

### Phase 3: Advanced Features

**Tasks:**

1. Multi-language SMS support
2. SMS delivery status tracking
3. Advanced monitoring and analytics
4. Security enhancements
5. Performance optimizations
6. Redis integration for distributed rate limiting
7. Audit log model and logging

**Deliverables:**

* Multi-language SMS
* Delivery status tracking
* Advanced analytics
* Production-ready rate limiting
* Comprehensive audit logging

***

## 13. Testing Requirements

### 13.1 Unit Tests

**Files to Test:**

* `src/lib/knock/send-otp.ts`
* `src/lib/knock/verify-otp.ts`
* `src/utils/phone-utils.ts`
* `src/utils/rate-limit.ts`

**Test Cases:**

* OTP code generation
* Phone number validation and normalization
* Rate limiting logic
* Error handling

### 13.2 Integration Tests

**Files to Test:**

* `src/actions/auth/phone/send-otp.ts`
* `src/actions/auth/phone/sign-in-phone.ts` (combined sign-in/sign-up)
* `src/actions/auth/phone/sign-up-phone.ts` (backward compatibility)
* `src/actions/auth/phone/link-phone.ts`

**Test Cases:**

* Knock API integration
* Better Auth phoneNumber plugin integration
* OTP send and verify flow
* Combined sign-up/sign-in flow (new user)
* Combined sign-up/sign-in flow (existing user)
* Account linking

### 13.3 End-to-End Tests

**Test Flows:**

* Complete authentication flow (phone number → OTP → automatic sign-up or sign-in)
* New user flow (phone number → OTP → account creation → sign in)
* Existing user flow (phone number → OTP → sign in)
* Phone number update flow
* Account linking flow

### 13.4 Security Tests

**Test Cases:**

* Rate limiting enforcement
* OTP brute force prevention
* Phone number uniqueness validation
* Error message security (no information leakage)
* API key protection

***

## 14. Environment Variables

### 14.1 Required Variables

```env
# Knock API Configuration
KNOCK_API_KEY=sk_test_... # Knock API key (required)
KNOCK_WORKFLOW_KEY=phone-otp # Knock workflow key for OTP (required)
```

### 14.2 Optional Variables

```env
# Knock API Configuration
KNOCK_API_URL=https://api.knock.app # Optional, defaults to production

# OTP Configuration
OTP_EXPIRY_MINUTES=10 # OTP expiration time in minutes (default: 10)
OTP_LENGTH=6 # OTP code length (default: 6)
```

### 14.3 Environment-Specific Configuration

**Development:**

```env
KNOCK_API_KEY=sk_test_development_key
KNOCK_WORKFLOW_KEY=phone-otp-dev
```

**Production:**

```env
KNOCK_API_KEY=sk_live_production_key
KNOCK_WORKFLOW_KEY=phone-otp
```

***

## 15. Dependencies

### 15.1 External Services

* **Knock** - SMS/OTP delivery service
  * API access required
  * Account setup required
  * API keys required
  * Workflow configuration required

### 15.2 NPM Packages

```json
{
  "dependencies": {
    "@knocklabs/node": "^1.0.0",
    "libphonenumber-js": "^1.11.0"
  }
}
```

**Installation:**

```bash
bun add @knocklabs/node libphonenumber-js
```

### 15.3 Internal Dependencies

* **Better Auth** - Authentication framework
  * `phoneNumber` plugin required
  * User model with `phoneNumber` and `phoneNumberVerified` fields
  * Session management

* **Database** - User data storage
  * User table with phone number fields
  * Prisma ORM for database access

***

## 16. Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.1 | 2025-01-27 | System | Combined sign-in and sign-up into single unified flow. Updated server actions to automatically handle both new and existing users. Added `isNewUser` flag to response. |
| 1.0 | 2025-01-27 | System | Initial technical requirements document for phone login with Knock |

***

## End of Document
