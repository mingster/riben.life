# Technical Requirements: Phone Login with Knock

**Date:** 2025-01-27  
**Status:** Active  
**Version:** 1.0

**Related Documents:**

* [PHONE-LOGIN-KNOCK.md](./PHONE-LOGIN-KNOCK.md) - Functional Requirements
* [SECURITY.md](../SECURITY.md)
* [ENVIRONMENT_VARIABLES.md](../ENVIRONMENT_VARIABLES.md)

***

## 1. Overview

This document specifies the technical architecture, implementation patterns, and technical constraints for phone number-based authentication using Knock as the SMS/OTP provider. It complements the Functional Requirements document by providing technical implementation details.

The phone authentication system integrates with Better Auth's `phoneNumber` plugin and uses Knock's API for OTP generation, delivery, and verification.

***

## 2. Architecture

### 2.1 Technology Stack

* **Framework:** Next.js 15 (App Router)
* **Language:** TypeScript
* **Database:** PostgreSQL (via Prisma ORM)
* **Authentication:** Better Auth with `phoneNumber` plugin
* **SMS/OTP Provider:** Knock (<https://knock.app>)
* **Knock SDK:** `@knocklabs/node`
* **Validation:** Zod v4
* **State Management:** React Server Components (default), Client Components with local state
* **Data Fetching:** SWR (client-side), Server Components (server-side)
* **UI Framework:** React 19, Tailwind CSS v4, shadcn/ui, Radix UI
* **Icons:** @tabler/icons-react
* **Package Manager:** Bun
* **Phone Number Validation:** `libphonenumber-js` (recommended)

### 2.2 Application Architecture

#### 2.2.1 Server Actions Pattern

All phone authentication-related data mutations use Next.js Server Actions with `next-safe-action` wrapper:

```typescript
// Pattern: actions/auth/phone/[action-name].ts
export const [actionName]Action = [actionClient]
  .metadata({ name: "[actionName]" })
  .schema([validationSchema])
  .action(async ({ parsedInput, ctx }) => {
    // Implementation
  });
```

**Action Client Types:**

* `baseClient` - For public/unauthenticated actions (e.g., send OTP, verify OTP for sign up/sign in)
* `userRequiredActionClient` - For authenticated user actions (e.g., link phone number, update phone number)
* `adminActionClient` - For system admin actions (e.g., view authentication logs)

#### 2.2.2 Component Architecture

* **Server Components (default):** Account settings pages, authentication pages (initial render)
* **Client Components:** Phone input forms, OTP verification forms, authentication flows
* **Pattern:** Server page → Client component → Server actions → Knock API

#### 2.2.3 Authentication Flow Architecture

1. **OTP Request:** Client component calls server action → Server action calls Knock API → OTP sent via SMS
2. **OTP Verification:** Client component calls server action → Server action calls Knock API → Better Auth creates session
3. **State Updates:** Client components update local state after successful authentication

#### 2.2.4 Knock Integration Architecture

```
┌─────────────┐
│   Client    │
│  Component  │
└──────┬──────┘
       │
       │ Server Action
       ▼
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│   Better    │─────▶│    Knock    │─────▶│     SMS     │
│    Auth     │      │     API     │      │   Delivery  │
└─────────────┘      └─────────────┘      └─────────────┘
       │
       │ Session Creation
       ▼
┌─────────────┐
│  Database   │
│  (Prisma)   │
└─────────────┘
```

***

## 3. Database Schema

### 3.1 User Model

The `User` model already includes phone number fields:

```prisma
model User {
  id                    String   @id @default(cuid())
  phoneNumber           String?  // E.164 format (e.g., +886912345678)
  phoneNumberVerified   Boolean? @default(false)
  // ... other fields
}
```

**Field Specifications:**

* `phoneNumber` (String, optional):
  * Format: E.164 international format (e.g., `+886912345678`)
  * Stored in normalized format (no spaces, dashes, or parentheses)
  * Indexed for fast lookup
  * Unique constraint (one phone number per user)
  * Encrypted at rest (if encryption is enabled)

* `phoneNumberVerified` (Boolean, default: false):
  * Indicates whether phone number has been verified via OTP
  * Set to `true` after successful OTP verification
  * Set to `false` when phone number is updated (until new number is verified)

### 3.2 OTP Storage (Temporary)

OTP codes are **NOT stored in the database**. Instead:

* **Knock manages OTP lifecycle:**
  * OTP codes are generated by Knock
  * OTP codes are stored temporarily by Knock
  * OTP codes are verified via Knock API
  * OTP codes expire automatically (default: 10 minutes)

* **Local tracking (optional, in-memory cache):**
  * Can use Redis or in-memory cache to track OTP send attempts
  * Used for rate limiting per phone number
  * Not required if Knock handles rate limiting

### 3.3 Audit Log Model (Optional)

For security and compliance, consider adding an audit log model:

```prisma
model PhoneAuthAuditLog {
  id              String   @id @default(cuid())
  eventType       String   // "OTP_SEND", "OTP_VERIFY", "SIGN_UP", "SIGN_IN", "PHONE_UPDATE"
  userId          String?   // Null for sign up attempts
  phoneNumber     String   // Masked: +886****5678
  ipAddress       String?
  userAgent       String?
  success         Boolean
  errorMessage    String?
  metadata        String?  // JSON string for additional data
  createdAt       BigInt   // Epoch milliseconds
  
  @@index([userId])
  @@index([phoneNumber])
  @@index([createdAt])
  @@index([eventType])
  @@map("phone_auth_audit_log")
}
```

**Note:** This is optional and can be added in Phase 2 or Phase 3 of implementation.

***

## 4. Knock API Integration

### 4.1 Knock SDK Setup

**Installation:**

```bash
bun add @knocklabs/node
```

**Environment Variables:**

```env
# Knock API Configuration
KNOCK_API_KEY=sk_test_... # Knock API key (required)
KNOCK_WORKFLOW_KEY=phone-otp # Knock workflow key for OTP (required)
KNOCK_API_URL=https://api.knock.app # Optional, defaults to production
```

### 4.2 Knock Client Initialization

**File:** `src/lib/knock/client.ts`

```typescript
import { Knock } from "@knocklabs/node";

if (!process.env.KNOCK_API_KEY) {
  throw new Error("KNOCK_API_KEY environment variable is required");
}

export const knockClient = new Knock(process.env.KNOCK_API_KEY, {
  host: process.env.KNOCK_API_URL || "https://api.knock.app",
});
```

### 4.3 Knock Workflow Configuration

**Workflow Setup in Knock Dashboard:**

1. Create a workflow named `phone-otp` (or use `KNOCK_WORKFLOW_KEY`)
2. Configure workflow to send SMS with OTP code
3. SMS template should include:
   * OTP code (6 digits)
   * App name/brand
   * Expiration time
   * Brief instructions

**Example SMS Template:**

```
Your riben.life verification code is: {{otp_code}}
This code will expire in 10 minutes.
Do not share this code with anyone.
```

### 4.4 Send OTP Implementation

**File:** `src/lib/knock/send-otp.ts`

```typescript
import { knockClient } from "./client";
import logger from "@/lib/logger";

export interface SendOTPParams {
  phoneNumber: string; // E.164 format
  userId?: string; // Optional, for existing users
}

export interface SendOTPResult {
  success: boolean;
  messageId?: string;
  error?: string;
}

export async function sendOTP({
  phoneNumber,
  userId,
}: SendOTPParams): Promise<SendOTPResult> {
  try {
    const workflowKey = process.env.KNOCK_WORKFLOW_KEY || "phone-otp";
    
    // Generate OTP code (6 digits)
    const otpCode = generateOTPCode();
    
    // Trigger Knock workflow
    const result = await knockClient.workflows.trigger(workflowKey, {
      recipients: [phoneNumber],
      data: {
        otp_code: otpCode,
        phone_number: phoneNumber,
        expires_in_minutes: 10,
      },
    });
    
    logger.info("OTP sent via Knock", {
      metadata: {
        phoneNumber: maskPhoneNumber(phoneNumber),
        userId,
        messageId: result.message_id,
      },
      tags: ["knock", "otp", "send"],
    });
    
    return {
      success: true,
      messageId: result.message_id,
    };
  } catch (error) {
    logger.error("Failed to send OTP via Knock", {
      metadata: {
        phoneNumber: maskPhoneNumber(phoneNumber),
        userId,
        error: error instanceof Error ? error.message : String(error),
      },
      tags: ["knock", "otp", "error"],
    });
    
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to send OTP",
    };
  }
}

function generateOTPCode(): string {
  // Generate 6-digit OTP code
  return Math.floor(100000 + Math.random() * 900000).toString();
}

function maskPhoneNumber(phoneNumber: string): string {
  // Mask phone number for logging: +886****5678
  if (phoneNumber.length <= 4) return "****";
  return phoneNumber.slice(0, -4) + "****";
}
```

**Note:** The actual OTP generation and verification may be handled by Knock's built-in OTP feature. Check Knock documentation for the recommended approach.

### 4.5 Verify OTP Implementation

**File:** `src/lib/knock/verify-otp.ts`

```typescript
import { knockClient } from "./client";
import logger from "@/lib/logger";

export interface VerifyOTPParams {
  phoneNumber: string; // E.164 format
  code: string; // 6-digit OTP code
}

export interface VerifyOTPResult {
  valid: boolean;
  error?: string;
}

export async function verifyOTP({
  phoneNumber,
  code,
}: VerifyOTPParams): Promise<VerifyOTPResult> {
  try {
    // Verify OTP with Knock API
    // Note: Exact API endpoint depends on Knock's OTP verification method
    // This is a placeholder - check Knock documentation for actual implementation
    
    const workflowKey = process.env.KNOCK_WORKFLOW_KEY || "phone-otp";
    
    // Example: Verify OTP via Knock API
    // const result = await knockClient.workflows.verify(workflowKey, {
    //   recipient: phoneNumber,
    //   code,
    // });
    
    // For now, return placeholder
    // TODO: Implement actual Knock OTP verification
    
    logger.info("OTP verification attempted", {
      metadata: {
        phoneNumber: maskPhoneNumber(phoneNumber),
        codeLength: code.length,
      },
      tags: ["knock", "otp", "verify"],
    });
    
    return {
      valid: true, // Placeholder
    };
  } catch (error) {
    logger.error("Failed to verify OTP via Knock", {
      metadata: {
        phoneNumber: maskPhoneNumber(phoneNumber),
        error: error instanceof Error ? error.message : String(error),
      },
      tags: ["knock", "otp", "error"],
    });
    
    return {
      valid: false,
      error: error instanceof Error ? error.message : "Failed to verify OTP",
    };
  }
}

function maskPhoneNumber(phoneNumber: string): string {
  if (phoneNumber.length <= 4) return "****";
  return phoneNumber.slice(0, -4) + "****";
}
```

**Important:** The exact OTP verification method depends on Knock's API. Check Knock documentation for the correct implementation.

### 4.6 Error Handling

**Knock API Error Types:**

* **Network Errors:** Retry with exponential backoff
* **Invalid API Key:** Log error, disable phone auth
* **Rate Limit Exceeded:** Return rate limit error to user
* **Service Unavailable:** Graceful degradation
* **Invalid Phone Number:** Return validation error

**Error Handling Pattern:**

```typescript
import { knockClient } from "./client";
import logger from "@/lib/logger";

async function handleKnockError(error: unknown): Promise<string> {
  if (error instanceof Error) {
    // Check for specific Knock error types
    if (error.message.includes("rate limit")) {
      return "Too many requests. Please try again later.";
    }
    if (error.message.includes("invalid phone")) {
      return "Invalid phone number format.";
    }
    if (error.message.includes("unauthorized")) {
      logger.error("Knock API key invalid", { metadata: { error: error.message } });
      return "SMS service temporarily unavailable. Please try again later.";
    }
  }
  
  logger.error("Knock API error", {
    metadata: { error: error instanceof Error ? error.message : String(error) },
  });
  
  return "Failed to send SMS. Please try again later.";
}
```

***

## 5. Better Auth Integration

### 5.1 Better Auth Configuration

**File:** `src/lib/auth.ts`

Update the `phoneNumber` plugin configuration:

```typescript
import { phoneNumber } from "better-auth/plugins";
import { sendOTP } from "@/lib/knock/send-otp";
import { verifyOTP } from "@/lib/knock/verify-otp";

export const auth = betterAuth({
  // ... other configuration
  plugins: [
    // ... other plugins
    phoneNumber({
      sendOTP: async ({ phoneNumber, code }, ctx) => {
        // Send OTP via Knock
        const result = await sendOTP({ phoneNumber });
        if (!result.success) {
          throw new Error(result.error || "Failed to send OTP");
        }
      },
      verifyOTP: async ({ phoneNumber, code }, ctx) => {
        // Verify OTP via Knock
        const result = await verifyOTP({ phoneNumber, code });
        return result.valid;
      },
    }),
    // ... other plugins
  ],
  user: {
    additionalFields: {
      phoneNumber: {
        type: "string",
        required: false,
        defaultValue: "",
      },
      phoneNumberVerified: {
        type: "boolean",
        required: false,
        defaultValue: false,
      },
      // ... other fields
    },
  },
});
```

### 5.2 Better Auth Phone Authentication Methods

Better Auth provides the following methods for phone authentication:

* `auth.api.signInPhone({ phoneNumber, code })` - Sign in with phone number
* `auth.api.signUpPhone({ phoneNumber, code })` - Sign up with phone number
* `auth.api.sendPhoneOTP({ phoneNumber })` - Send OTP code
* `auth.api.verifyPhoneOTP({ phoneNumber, code })` - Verify OTP code

**Client-side Usage:**

```typescript
"use client";

import { authClient } from "@/lib/auth-client";

// Send OTP
const { data, error } = await authClient.signInPhone.sendOTP({
  phoneNumber: "+886912345678",
});

// Verify OTP and sign in
const { data: session, error: verifyError } = await authClient.signInPhone.verifyOTP({
  phoneNumber: "+886912345678",
  code: "123456",
});
```

### 5.3 Account Linking

Better Auth supports account linking for users with multiple authentication methods:

* Users can link phone number to existing email account
* Users can link email to existing phone account
* Account linking follows Better Auth's `accountLinking` configuration

**Configuration:**

```typescript
export const auth = betterAuth({
  account: {
    accountLinking: {
      enabled: true,
      allowDifferentEmails: true,
      trustedProviders: ["google", "line", "apple", "phone"],
    },
  },
  // ... other configuration
});
```

***

## 6. Server Actions

### 6.1 Send OTP Action

**File:** `src/actions/auth/phone/send-otp.ts`

```typescript
"use server";

import { z } from "zod";
import { baseClient } from "@/utils/actions/safe-action";
import { sendOTP } from "@/lib/knock/send-otp";
import { normalizePhoneNumber, validatePhoneNumber } from "@/utils/phone-utils";
import { checkRateLimit } from "@/utils/rate-limit";

const sendOTPSchema = z.object({
  phoneNumber: z.string().min(1, "Phone number is required"),
});

export const sendOTPAction = baseClient
  .metadata({ name: "sendOTP" })
  .schema(sendOTPSchema)
  .action(async ({ parsedInput, ctx }) => {
    const { phoneNumber } = parsedInput;
    
    // Normalize phone number to E.164 format
    const normalizedPhone = normalizePhoneNumber(phoneNumber);
    
    // Validate phone number format
    const isValid = validatePhoneNumber(normalizedPhone);
    if (!isValid) {
      return {
        serverError: "Invalid phone number format. Please use international format (e.g., +886912345678).",
      };
    }
    
    // Check rate limit
    const ipAddress = ctx?.ipAddress || "unknown";
    const rateLimitResult = await checkRateLimit({
      phoneNumber: normalizedPhone,
      ipAddress,
    });
    
    if (!rateLimitResult.allowed) {
      return {
        serverError: rateLimitResult.message || "Too many requests. Please try again later.",
      };
    }
    
    // Send OTP via Knock
    const result = await sendOTP({ phoneNumber: normalizedPhone });
    
    if (!result.success) {
      return {
        serverError: result.error || "Failed to send OTP. Please try again later.",
      };
    }
    
    return {
      data: {
        success: true,
        message: "OTP code sent successfully.",
      },
    };
  });
```

### 6.2 Verify OTP and Sign Up Action

**File:** `src/actions/auth/phone/sign-up-phone.ts`

```typescript
"use server";

import { z } from "zod";
import { baseClient } from "@/utils/actions/safe-action";
import { auth } from "@/lib/auth";
import { verifyOTP } from "@/lib/knock/verify-otp";
import { normalizePhoneNumber, validatePhoneNumber } from "@/utils/phone-utils";
import { sqlClient } from "@/lib/prismadb";

const signUpPhoneSchema = z.object({
  phoneNumber: z.string().min(1, "Phone number is required"),
  code: z.string().length(6, "OTP code must be 6 digits"),
});

export const signUpPhoneAction = baseClient
  .metadata({ name: "signUpPhone" })
  .schema(signUpPhoneSchema)
  .action(async ({ parsedInput, ctx }) => {
    const { phoneNumber, code } = parsedInput;
    
    // Normalize phone number
    const normalizedPhone = normalizePhoneNumber(phoneNumber);
    
    // Validate phone number format
    const isValid = validatePhoneNumber(normalizedPhone);
    if (!isValid) {
      return {
        serverError: "Invalid phone number format.",
      };
    }
    
    // Check if phone number is already registered
    const existingUser = await sqlClient.user.findFirst({
      where: { phoneNumber: normalizedPhone },
    });
    
    if (existingUser) {
      return {
        serverError: "This phone number is already registered. Please sign in instead.",
      };
    }
    
    // Verify OTP via Knock
    const verifyResult = await verifyOTP({
      phoneNumber: normalizedPhone,
      code,
    });
    
    if (!verifyResult.valid) {
      return {
        serverError: verifyResult.error || "Invalid OTP code. Please try again.",
      };
    }
    
    // Create user account via Better Auth
    const result = await auth.api.signUpPhone({
      phoneNumber: normalizedPhone,
      code,
    });
    
    if (result.error) {
      return {
        serverError: result.error.message || "Failed to create account.",
      };
    }
    
    return {
      data: {
        success: true,
        user: result.data.user,
        session: result.data.session,
      },
    };
  });
```

### 6.3 Verify OTP and Sign In Action

**File:** `src/actions/auth/phone/sign-in-phone.ts`

```typescript
"use server";

import { z } from "zod";
import { baseClient } from "@/utils/actions/safe-action";
import { auth } from "@/lib/auth";
import { verifyOTP } from "@/lib/knock/verify-otp";
import { normalizePhoneNumber, validatePhoneNumber } from "@/utils/phone-utils";
import { sqlClient } from "@/lib/prismadb";

const signInPhoneSchema = z.object({
  phoneNumber: z.string().min(1, "Phone number is required"),
  code: z.string().length(6, "OTP code must be 6 digits"),
});

export const signInPhoneAction = baseClient
  .metadata({ name: "signInPhone" })
  .schema(signInPhoneSchema)
  .action(async ({ parsedInput, ctx }) => {
    const { phoneNumber, code } = parsedInput;
    
    // Normalize phone number
    const normalizedPhone = normalizePhoneNumber(phoneNumber);
    
    // Validate phone number format
    const isValid = validatePhoneNumber(normalizedPhone);
    if (!isValid) {
      return {
        serverError: "Invalid phone number format.",
      };
    }
    
    // Check if phone number is registered
    const existingUser = await sqlClient.user.findFirst({
      where: { phoneNumber: normalizedPhone },
    });
    
    if (!existingUser) {
      return {
        serverError: "This phone number is not registered. Please sign up instead.",
      };
    }
    
    // Verify OTP via Knock
    const verifyResult = await verifyOTP({
      phoneNumber: normalizedPhone,
      code,
    });
    
    if (!verifyResult.valid) {
      return {
        serverError: verifyResult.error || "Invalid OTP code. Please try again.",
      };
    }
    
    // Sign in via Better Auth
    const result = await auth.api.signInPhone({
      phoneNumber: normalizedPhone,
      code,
    });
    
    if (result.error) {
      return {
        serverError: result.error.message || "Failed to sign in.",
      };
    }
    
    return {
      data: {
        success: true,
        user: result.data.user,
        session: result.data.session,
      },
    };
  });
```

### 6.4 Link Phone Number Action

**File:** `src/actions/auth/phone/link-phone.ts`

```typescript
"use server";

import { z } from "zod";
import { userRequiredActionClient } from "@/utils/actions/safe-action";
import { verifyOTP } from "@/lib/knock/verify-otp";
import { normalizePhoneNumber, validatePhoneNumber } from "@/utils/phone-utils";
import { sqlClient } from "@/lib/prismadb";
import { getUtcNowEpoch } from "@/utils/datetime-utils";

const linkPhoneSchema = z.object({
  phoneNumber: z.string().min(1, "Phone number is required"),
  code: z.string().length(6, "OTP code must be 6 digits"),
});

export const linkPhoneAction = userRequiredActionClient
  .metadata({ name: "linkPhone" })
  .schema(linkPhoneSchema)
  .action(async ({ parsedInput, ctx }) => {
    const { phoneNumber, code } = parsedInput;
    const userId = ctx?.userId;
    
    if (!userId) {
      return {
        serverError: "User not authenticated.",
      };
    }
    
    // Normalize phone number
    const normalizedPhone = normalizePhoneNumber(phoneNumber);
    
    // Validate phone number format
    const isValid = validatePhoneNumber(normalizedPhone);
    if (!isValid) {
      return {
        serverError: "Invalid phone number format.",
      };
    }
    
    // Check if phone number is already registered to another user
    const existingUser = await sqlClient.user.findFirst({
      where: {
        phoneNumber: normalizedPhone,
        NOT: { id: userId },
      },
    });
    
    if (existingUser) {
      return {
        serverError: "This phone number is already registered to another account.",
      };
    }
    
    // Verify OTP via Knock
    const verifyResult = await verifyOTP({
      phoneNumber: normalizedPhone,
      code,
    });
    
    if (!verifyResult.valid) {
      return {
        serverError: verifyResult.error || "Invalid OTP code. Please try again.",
      };
    }
    
    // Update user's phone number
    const now = getUtcNowEpoch();
    await sqlClient.user.update({
      where: { id: userId },
      data: {
        phoneNumber: normalizedPhone,
        phoneNumberVerified: true,
        updatedAt: new Date(now.toString()),
      },
    });
    
    return {
      data: {
        success: true,
        phoneNumber: normalizedPhone,
        verified: true,
      },
    };
  });
```

### 6.5 Update Phone Number Action

**File:** `src/actions/auth/phone/update-phone.ts`

Similar to `linkPhoneAction`, but requires verification of new phone number and optionally notifies old phone number.

***

## 7. Rate Limiting

### 7.1 Rate Limiting Strategy

**Per Phone Number:**

* Maximum 3 OTP requests per 15 minutes
* Maximum 5 OTP requests per hour
* Maximum 10 OTP requests per 24 hours

**Per IP Address:**

* Maximum 10 OTP requests per 15 minutes
* Maximum 20 OTP requests per hour
* Maximum 50 OTP requests per 24 hours

### 7.2 Rate Limiting Implementation

**File:** `src/utils/rate-limit.ts`

```typescript
import { sqlClient } from "@/lib/prismadb";
import logger from "@/lib/logger";

interface RateLimitCheck {
  phoneNumber?: string;
  ipAddress?: string;
}

interface RateLimitResult {
  allowed: boolean;
  message?: string;
  retryAfter?: number; // seconds
}

// In-memory cache for rate limiting (or use Redis in production)
const rateLimitCache = new Map<string, number[]>();

export async function checkRateLimit({
  phoneNumber,
  ipAddress,
}: RateLimitCheck): Promise<RateLimitResult> {
  const now = Date.now();
  const windows = [
    { duration: 15 * 60 * 1000, max: 3 }, // 15 minutes, 3 requests
    { duration: 60 * 60 * 1000, max: 5 }, // 1 hour, 5 requests
    { duration: 24 * 60 * 60 * 1000, max: 10 }, // 24 hours, 10 requests
  ];
  
  // Check phone number rate limit
  if (phoneNumber) {
    const phoneKey = `phone:${phoneNumber}`;
    const phoneRequests = rateLimitCache.get(phoneKey) || [];
    
    for (const window of windows) {
      const recentRequests = phoneRequests.filter(
        (timestamp) => now - timestamp < window.duration
      );
      
      if (recentRequests.length >= window.max) {
        const oldestRequest = Math.min(...recentRequests);
        const retryAfter = Math.ceil((oldestRequest + window.duration - now) / 1000);
        
        logger.warn("Phone number rate limit exceeded", {
          metadata: {
            phoneNumber: maskPhoneNumber(phoneNumber),
            window: `${window.duration}ms`,
            max: window.max,
            current: recentRequests.length,
          },
          tags: ["rate-limit", "phone"],
        });
        
        return {
          allowed: false,
          message: `Too many requests. Please try again in ${retryAfter} seconds.`,
          retryAfter,
        };
      }
    }
    
    // Add current request
    phoneRequests.push(now);
    rateLimitCache.set(phoneKey, phoneRequests);
    
    // Clean up old entries
    cleanupCache(phoneKey, phoneRequests);
  }
  
  // Check IP address rate limit
  if (ipAddress) {
    const ipKey = `ip:${ipAddress}`;
    const ipRequests = rateLimitCache.get(ipKey) || [];
    const ipWindows = [
      { duration: 15 * 60 * 1000, max: 10 },
      { duration: 60 * 60 * 1000, max: 20 },
      { duration: 24 * 60 * 60 * 1000, max: 50 },
    ];
    
    for (const window of ipWindows) {
      const recentRequests = ipRequests.filter(
        (timestamp) => now - timestamp < window.duration
      );
      
      if (recentRequests.length >= window.max) {
        const oldestRequest = Math.min(...recentRequests);
        const retryAfter = Math.ceil((oldestRequest + window.duration - now) / 1000);
        
        logger.warn("IP address rate limit exceeded", {
          metadata: {
            ipAddress,
            window: `${window.duration}ms`,
            max: window.max,
            current: recentRequests.length,
          },
          tags: ["rate-limit", "ip"],
        });
        
        return {
          allowed: false,
          message: `Too many requests. Please try again in ${retryAfter} seconds.`,
          retryAfter,
        };
      }
    }
    
    // Add current request
    ipRequests.push(now);
    rateLimitCache.set(ipKey, ipRequests);
    
    // Clean up old entries
    cleanupCache(ipKey, ipRequests);
  }
  
  return { allowed: true };
}

function cleanupCache(key: string, requests: number[]): void {
  const now = Date.now();
  const maxAge = 24 * 60 * 60 * 1000; // 24 hours
  const filtered = requests.filter((timestamp) => now - timestamp < maxAge);
  
  if (filtered.length === 0) {
    rateLimitCache.delete(key);
  } else {
    rateLimitCache.set(key, filtered);
  }
}

function maskPhoneNumber(phoneNumber: string): string {
  if (phoneNumber.length <= 4) return "****";
  return phoneNumber.slice(0, -4) + "****";
}
```

**Note:** For production, consider using Redis for distributed rate limiting across multiple servers.

***

## 8. Phone Number Validation

### 8.1 Phone Number Utilities

**File:** `src/utils/phone-utils.ts`

```typescript
import { parsePhoneNumber, isValidPhoneNumber } from "libphonenumber-js";

/**
 * Normalize phone number to E.164 format
 * @param phoneNumber - Phone number in any format
 * @returns Normalized phone number in E.164 format (e.g., +886912345678)
 */
export function normalizePhoneNumber(phoneNumber: string): string {
  try {
    // Remove spaces, dashes, parentheses
    const cleaned = phoneNumber.replace(/[\s\-\(\)]/g, "");
    
    // Parse and normalize to E.164
    const parsed = parsePhoneNumber(cleaned);
    return parsed.number; // Returns E.164 format (e.g., +886912345678)
  } catch (error) {
    // If parsing fails, try to add + prefix if missing
    if (!phoneNumber.startsWith("+")) {
      return `+${phoneNumber}`;
    }
    return phoneNumber;
  }
}

/**
 * Validate phone number format
 * @param phoneNumber - Phone number in E.164 format
 * @returns true if valid, false otherwise
 */
export function validatePhoneNumber(phoneNumber: string): boolean {
  try {
    return isValidPhoneNumber(phoneNumber);
  } catch (error) {
    return false;
  }
}

/**
 * Format phone number for display (user-friendly format)
 * @param phoneNumber - Phone number in E.164 format
 * @returns Formatted phone number (e.g., +886 912 345 678)
 */
export function formatPhoneNumber(phoneNumber: string): string {
  try {
    const parsed = parsePhoneNumber(phoneNumber);
    return parsed.formatInternational(); // Returns +886 912 345 678
  } catch (error) {
    return phoneNumber;
  }
}

/**
 * Mask phone number for privacy (e.g., +886****5678)
 * @param phoneNumber - Phone number in E.164 format
 * @returns Masked phone number
 */
export function maskPhoneNumber(phoneNumber: string): string {
  if (phoneNumber.length <= 4) return "****";
  return phoneNumber.slice(0, -4) + "****";
}
```

**Installation:**

```bash
bun add libphonenumber-js
```

***

## 9. Error Handling

### 9.1 Error Types

**Validation Errors:**

* Invalid phone number format
* Phone number already registered
* Phone number not registered
* Invalid OTP code
* OTP code expired

**Rate Limiting Errors:**

* Too many OTP requests
* Rate limit exceeded

**Knock API Errors:**

* Network errors
* Invalid API key
* Service unavailable
* SMS delivery failure

**Better Auth Errors:**

* Account creation failure
* Session creation failure
* Account linking failure

### 9.2 Error Handling Pattern

All server actions return:

```typescript
{
  data?: T;           // Success data
  serverError?: string; // Error message
  validationErrors?: {  // Validation errors
    [field: string]: string[];
  };
}
```

**Client-side Error Handling:**

```typescript
"use client";

const result = await sendOTPAction({ phoneNumber });

if (result?.serverError) {
  toastError({ description: result.serverError });
  return;
}

if (result?.validationErrors) {
  // Handle validation errors
  Object.entries(result.validationErrors).forEach(([field, errors]) => {
    form.setError(field, { message: errors[0] });
  });
  return;
}

// Success
toastSuccess({ description: "OTP sent successfully!" });
```

***

## 10. Security Requirements

### 10.1 OTP Security

* **OTP Generation:** Cryptographically random, 6 digits
* **OTP Storage:** Not stored in database (managed by Knock)
* **OTP Expiration:** 10 minutes (configurable)
* **OTP Single-Use:** Invalidated after successful verification
* **OTP Attempt Limits:** Maximum 5 attempts per code

### 10.2 Phone Number Security

* **Encryption at Rest:** Phone numbers encrypted in database (if encryption enabled)
* **Masking in UI:** Phone numbers masked in UI and logs (e.g., +886****5678)
* **Access Control:** Only user and admins can view phone numbers
* **Data Protection:** Compliant with GDPR, CCPA, and other regulations

### 10.3 Rate Limiting Security

* **Per Phone Number:** Prevents abuse of OTP requests
* **Per IP Address:** Prevents distributed attacks
* **Violation Logging:** All rate limit violations logged
* **Account Lockout:** Optional account lockout after repeated failures

### 10.4 API Security

* **API Key Protection:** Knock API keys stored in environment variables
* **HTTPS Only:** All API requests over HTTPS
* **Input Validation:** All inputs validated with Zod schemas
* **SQL Injection Prevention:** Prisma ORM with parameterized queries

***

## 11. Performance Requirements

### 11.1 Response Times

* **OTP Send:** < 5 seconds (Knock API: < 2s, SMS delivery: < 3s)
* **OTP Verify:** < 2 seconds (Knock API: < 1s, Database: < 1s)
* **Sign Up/Sign In:** < 3 seconds (including OTP verification)
* **Phone Number Update:** < 3 seconds

### 11.2 Database Optimization

* **Indexes:** `phoneNumber` field indexed for fast lookup
* **Query Optimization:** Use `select` to limit returned fields
* **Connection Pooling:** Prisma connection pooling enabled

### 11.3 Caching

* **Rate Limit Cache:** In-memory cache (or Redis for production)
* **Phone Number Lookup:** Optional caching for frequently accessed phone numbers

***

## 12. Implementation Phases

### Phase 1: Basic Phone Authentication (MVP)

**Tasks:**

1. Install Knock SDK: `bun add @knocklabs/node`
2. Install phone validation library: `bun add libphonenumber-js`
3. Create Knock client (`src/lib/knock/client.ts`)
4. Implement `sendOTP` function (`src/lib/knock/send-otp.ts`)
5. Implement `verifyOTP` function (`src/lib/knock/verify-otp.ts`)
6. Update Better Auth configuration (`src/lib/auth.ts`)
7. Create phone number utilities (`src/utils/phone-utils.ts`)
8. Create server actions:
   * `send-otp.ts`
   * `sign-up-phone.ts`
   * `sign-in-phone.ts`
9. Create UI components:
   * Phone input form
   * OTP verification form
   * Sign up/sign in pages
10. Basic error handling
11. Basic rate limiting

**Deliverables:**

* Users can sign up with phone number
* Users can sign in with phone number
* OTP codes sent via Knock SMS
* OTP codes verified via Knock API

### Phase 2: Enhanced Features

**Tasks:**

1. Implement rate limiting (`src/utils/rate-limit.ts`)
2. Create `link-phone.ts` action
3. Create `update-phone.ts` action
4. Add phone number management to account settings
5. Enhanced error handling
6. Audit logging (optional)
7. Account linking UI

**Deliverables:**

* Phone number verification in account settings
* Phone number update functionality
* Account linking (phone + email)
* Rate limiting enforcement
* Enhanced error messages

### Phase 3: Advanced Features

**Tasks:**

1. Multi-language SMS support
2. SMS delivery status tracking
3. Advanced monitoring and analytics
4. Security enhancements
5. Performance optimizations
6. Redis integration for distributed rate limiting
7. Audit log model and logging

**Deliverables:**

* Multi-language SMS
* Delivery status tracking
* Advanced analytics
* Production-ready rate limiting
* Comprehensive audit logging

***

## 13. Testing Requirements

### 13.1 Unit Tests

**Files to Test:**

* `src/lib/knock/send-otp.ts`
* `src/lib/knock/verify-otp.ts`
* `src/utils/phone-utils.ts`
* `src/utils/rate-limit.ts`

**Test Cases:**

* OTP code generation
* Phone number validation and normalization
* Rate limiting logic
* Error handling

### 13.2 Integration Tests

**Files to Test:**

* `src/actions/auth/phone/send-otp.ts`
* `src/actions/auth/phone/sign-up-phone.ts`
* `src/actions/auth/phone/sign-in-phone.ts`
* `src/actions/auth/phone/link-phone.ts`

**Test Cases:**

* Knock API integration
* Better Auth phoneOTP plugin integration
* OTP send and verify flow
* Account creation and sign in
* Account linking

### 13.3 End-to-End Tests

**Test Flows:**

* Complete sign up flow (phone number → OTP → account creation)
* Complete sign in flow (phone number → OTP → session creation)
* Phone number update flow
* Account linking flow

### 13.4 Security Tests

**Test Cases:**

* Rate limiting enforcement
* OTP brute force prevention
* Phone number uniqueness validation
* Error message security (no information leakage)
* API key protection

***

## 14. Environment Variables

### 14.1 Required Variables

```env
# Knock API Configuration
KNOCK_API_KEY=sk_test_... # Knock API key (required)
KNOCK_WORKFLOW_KEY=phone-otp # Knock workflow key for OTP (required)
```

### 14.2 Optional Variables

```env
# Knock API Configuration
KNOCK_API_URL=https://api.knock.app # Optional, defaults to production

# OTP Configuration
OTP_EXPIRY_MINUTES=10 # OTP expiration time in minutes (default: 10)
OTP_LENGTH=6 # OTP code length (default: 6)
```

### 14.3 Environment-Specific Configuration

**Development:**

```env
KNOCK_API_KEY=sk_test_development_key
KNOCK_WORKFLOW_KEY=phone-otp-dev
```

**Production:**

```env
KNOCK_API_KEY=sk_live_production_key
KNOCK_WORKFLOW_KEY=phone-otp
```

***

## 15. Dependencies

### 15.1 External Services

* **Knock** - SMS/OTP delivery service
  * API access required
  * Account setup required
  * API keys required
  * Workflow configuration required

### 15.2 NPM Packages

```json
{
  "dependencies": {
    "@knocklabs/node": "^1.0.0",
    "libphonenumber-js": "^1.11.0"
  }
}
```

**Installation:**

```bash
bun add @knocklabs/node libphonenumber-js
```

### 15.3 Internal Dependencies

* **Better Auth** - Authentication framework
  * `phoneNumber` plugin required
  * User model with `phoneNumber` and `phoneNumberVerified` fields
  * Session management

* **Database** - User data storage
  * User table with phone number fields
  * Prisma ORM for database access

***

## 16. Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-01-27 | System | Initial technical requirements document for phone login with Knock |

***

## End of Document

